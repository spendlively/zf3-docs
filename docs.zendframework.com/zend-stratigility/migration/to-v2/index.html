<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">  
    <link rel="shortcut icon" href="../../img/favicon.ico">

    <title>To Version 2 - zend-stratigility</title>

    <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css" rel="stylesheet">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/font-hack/2.018/css/hack.min.css">
    <link href="//fonts.googleapis.com/css?family=PT+Sans:400,400italic,700,700italic&subset=latin-ext,latin" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,700italic,400,300,600,700&subset=latin-ext,latin" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Libre+Baskerville:400,400italic,700&subset=latin,latin-ext" rel="stylesheet" type="text/css">
    <link href="../../css/base.css" rel="stylesheet">
    <link href="../../css/zf-web.css" rel="stylesheet">
    <link href="../../css/zf.css" rel="stylesheet">
    <link href="../../css/prism-zf.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

    <script src="https://ajax.googleapis.com/ajax/libs/webfont/1.5.18/webfont.js"></script>
    <script>
    WebFont.load({
        google: {
            families: ['Open Sans', 'PT Sans']
        }
    });
    </script>

    
</head>

<body>

    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            

            <!-- Main title -->
            <span class="navbar-brand">
              <a class="logo-link" href="http://framework.zend.com" data-toggle="tooltip" data-placement="bottom" title="Zend Framework"><img src="../../img/zf-logo-mark.svg" height="28" alt="Zend Framework" /></a>
              <a href="../..">zend-stratigility</a>
            </span>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                
                
                    <li >
                        <a href="../..">Home</a>
                    </li>
                
                
                
                    <li >
                        <a href="../../intro/">Intro</a>
                    </li>
                
                
                
                    <li class="dropdown active">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Reference <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li >
    <a href="../../install/">Installation and Requirements</a>
</li>

                        
                            
<li >
    <a href="../../usage/">Usage</a>
</li>

                        
                            
<li >
    <a href="../../middleware/">Middleware</a>
</li>

                        
                            
<li >
    <a href="../../error-handlers/">Error Handlers</a>
</li>

                        
                            
<li >
    <a href="../../creating-middleware/">Creating Middleware</a>
</li>

                        
                            
<li >
    <a href="../../executing-middleware/">Executing and composing middleware</a>
</li>

                        
                            
<li >
    <a href="../../api/">API Reference</a>
</li>

                        
                            
  <li class="dropdown-submenu">
    <a tabindex="-1" href="">Migration</a>
    <ul class="dropdown-menu">
        
            
<li class="active">
    <a href="./">To Version 2</a>
</li>

        
    </ul>
  </li>

                        
                        </ul>
                    </li>
                
                
                </ul>
            

            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="#" class="component-toggle" data-toggle="tooltip" data-placement="bottom" title="Show component list">
                        <i class="fa fa-book"></i> Components
                    </a>
                </li>

                <li>
                    <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                        <i class="fa fa-search"></i> Search
                    </a>
                </li>
                
                    <li>
                        <a href="https://github.com/zendframework/zend-stratigility">
                            
                                <i class="fa fa-github"></i>
                            
                            GitHub
                        </a>
                    </li>
                
            </ul>
        </div>
    </div>
</div>

    <!-- content:begin -->
    <div id="page-top" class="container docs">
        
        <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#migrating-to-version-2">Migrating to version 2</a></li>
        
            <li><a href="#original-request-response-and-uri">Original request, response, and URI</a></li>
        
            <li><a href="#error-handling">Error handling</a></li>
        
            <li><a href="#http-interop-compatibility">http-interop compatibility</a></li>
        
            <li><a href="#deprecated-functionality">Deprecated functionality</a></li>
        
            <li><a href="#interfacesignature-changes">Interface/signature changes</a></li>
        
            <li><a href="#removed-functionality">Removed functionality</a></li>
        
    
    </ul>

    
    <ul class="pager hidden-print">
      <li class="previous">
        <a rel="prev" href="../../api/"><i class="fa fa-arrow-left"></i> Previous</a>
      </li>
      <li class="next disabled ">
        <a rel="next" >Next <i class="fa fa-arrow-right"></i></a>
      </li>
    </ul>
    
</div></div>
        <div class="col-md-9" role="main">

<ol class="breadcrumb" role="navigation" aria-label="breadcrumbs navigation">
  <li><a href="../..">zend-stratigility</a> &raquo;</li>
  
    
      
        <li>Reference &raquo;</li>
      
    
      
        <li>Migration &raquo;</li>
      
    
  
  <li class="active">To Version 2</li>
</ol>

<h1 id="migrating-to-version-2">Migrating to version 2</h1>
<p>Version 2 of Stratigility makes several breaking changes to the API in
order to provide more flexibility, promote interoperability, and reduce
complexity.</p>
<p>To help you prepare your code for version 2, version 1.3.0 provides several
forwards compatibility features to assist you in the process. However, some
changes will still require changes to your code following the 2.0 release.</p>
<h2 id="original-request-response-and-uri">Original request, response, and URI</h2>
<p>In the original 1.X releases, Stratigility would decorate the request and
response instances with <code>Zend\Stratigility\Http\Request</code> and
<code>Zend\Stratigility\Http\Response</code>, respectively. This was done to facilitate
access to the incoming request in cases of nested layers, where the URI path
may have been truncated (<code>Next</code> truncates matched paths when executing a layer
if a path was provided when piping the middleware).</p>
<p>Internally, prior to 1.3, only <code>Zend\Stratigility\FinalHandler</code> was still using
this functionality:</p>
<ul>
<li>It would query the original request to get the original URI when creating a
  404 response message.</li>
<li>It passes the decorated request and response instances to <code>onerror</code> handlers.</li>
</ul>
<p>Starting with 1.3.0, we now deprecate these message decorators, and recommend
against their usage.</p>
<p>If you still need access to the original request, response, or URI instance, we
recommend the following:</p>
<ul>
<li>Pipe <code>Zend\Stratigility\Middleware\OriginalMessages</code> as the outermost layer of
  your application. This will inject the following request attributes into
  layers beneath it:<ul>
<li><code>originalRequest</code>, mapping to the request provided to it at invocation.</li>
<li><code>originalResponse</code>, mapping to the response provided to it at invocation.</li>
<li><code>originalUri</code>, mapping to the URI composed by the request provided to it at
  invocation.</li>
</ul>
</li>
</ul>
<p>You can then access these values within other middleware:</p>
<pre class="codehilite"><code class="language-php linenums">$originalRequest = $request-&gt;getAttribute('originalRequest');
$originalResponse = $request-&gt;getAttribute('originalResponse');
$originalUri = $request-&gt;getAttribute('originalUri');</code></pre>

<p>Internally, starting with 1.3.0, we have updated the request decorator to add
the <code>originalRequest</code> attribute, and the <code>FinalHandler</code> to check for this,
instead of the decorated instance.</p>
<p>Finally, if you are creating an <code>onerror</code> handler for the <code>FinalHandler</code>, update
your typehints to refer to the PSR-7 request and response interfaces instead of
the Stratigility decorators, if you aren't already.</p>
<p>The <code>Zend\Stratigility\Http</code> classes, interfaces, and namespace are removed
in version 2.0.0.</p>
<h2 id="error-handling">Error handling</h2>
<p>Prior to version 1.3, the recommended way to handle errors was via
<a href="../../error-handlers/#legacy-error-middleware">error middleware</a>, special
middleware that accepts an additional initial argument representing an error. On
top of this, we provide the concept of a "final handler", pseudo-middleware that
is executed by the <code>Next</code> implementation when the middleware stack is exhausted,
but no response has been returned.</p>
<p>These approaches, however, have several shortcomings:</p>
<ul>
<li>No other middleware frameworks implement the error middleware feature, which
  means any middleware that calls <code>$next()</code> with the error argument will not
  work in those other systems, and error middleware written for Stratigility
  cannot be composed in other systems.</li>
<li>The <code>FinalHandler</code> implementation hits edge cases when empty responses are
  intended.</li>
<li>Neither combination works well with error or exception handlers.</li>
</ul>
<p>Starting in 1.3, we are promoting using standard middleware layers as error
handlers, instead of using the existing error middleware/final handler system.</p>
<p>The first step is to opt-in to having throwables and exceptions raised by
middleware, instead of having the dispatcher catch them and then invoke
middleware. Do this via the <code>MiddlewarePipe::raiseThrowables()</code> method:</p>
<pre class="codehilite"><code class="language-php linenums">$pipeline = new MiddlewarePipe();
$pipeline-&gt;raiseThrowables();</code></pre>

<p>Once you have done that you may start using some of the new functionality, as
well as augmented existing functionality:</p>
<ul>
<li><a href="../../error-handlers/#handling-404-conditions">NotFoundHandler middleware</a></li>
<li><a href="../../error-handlers/#handling-php-errors-and-exceptions">ErrorHandler middleware</a></li>
<li><code>Zend\Stratigility\NoopFinalHandler</code> (see next section)</li>
</ul>
<p>Updating your application to use these features will ensure you are forwards
compatible with version 2 releases.</p>
<h3 id="no-op-final-handler">No-op final handler</h3>
<p>When using the <code>NotFoundHandler</code> and <code>ErrorHandler</code> middleware (or custom
middleware you drop in place of them), the <code>FinalHandler</code> implementation loses
most of its meaning, as you are now handling errors and 404 conditions as
middleware layers.</p>
<p>However, you still need to ensure that the pipeline returns a response,
regardless of how the pipeline is setup, and for that we still need some form of
"final" handler that can do so. (In fact, starting in version 2, the <code>$out</code>
argument is renamed to <code>$delegate</code>, and is a <em>required</em> argument of the
<code>MiddlewarePipe</code>.)</p>
<p>Starting in version 1.3, we now offer a <code>Zend\Stratigility\NoopFinalHandler</code>
implementation, which simply returns the response passed to it. You can compose
it in your application in one of two ways:</p>
<ul>
<li>By passing it explicitly when invoking the middleware pipeline.</li>
<li>By passing it to <code>Zend\Diactoros\Server::listen()</code>.</li>
</ul>
<p>If you are not using <code>Zend\Diactoros\Server</code> to execute your application, but
instead invoking your pipeline manually, use the following:</p>
<pre class="codehilite"><code class="language-php linenums">$response = $app($request, $response, new NoopFinalHandler());</code></pre>

<p>If you are using <code>Zend\Diactoros\Server</code>, you will need to pass the final
handler you wish to use as an argument to the <code>listen()</code> method; that method
will then pass that value as the third argument to <code>MiddlewarePipe</code> as shown
above:</p>
<pre class="codehilite"><code class="language-php linenums">$server-&gt;listen(new NoopFinalHandler());</code></pre>

<p>Both approaches above are fully forwards compatible with version 2, and will
work in all version 1 releases as well.</p>
<p>(You can also compose your own custom final handler; it only needs to accept a
request and a response, and be guaranteed to return a response instance.)</p>
<p>To summarize:</p>
<ul>
<li>Call the <code>raiseThrowables()</code> method of your <code>MiddlewarePipe</code> instance to
  opt-in to the new error handling strategy.</li>
<li>Use the new <code>Zend\Stratigility\Middleware\NotFoundHandler</code> as the innermost
  layer of your application pipeline in order to provide 404 responses.</li>
<li>Use the new <code>Zend\Stratigility\Middleware\ErrorHandler</code> middleware as the
  outermost (or close to outermost) layer of your application pipeline in order
  to handle exceptions.</li>
<li>Use the <code>Zend\Stratigility\NoopFinalHandler</code> as the <code>$out</code> argument when
  dispatching your application pipeline.</li>
</ul>
<h2 id="http-interop-compatibility">http-interop compatibility</h2>
<h3 id="http-middleware-020-and-stratigility-13">http-middleware 0.2.0 and Stratigility 1.3</h3>
<p>Starting in version 1.3.0, we offer compatibility with
<a href="https://github.com/http-interop/http-middleware/tree/ff545c87e97bf4d88f0cb7eb3e89f99aaa53d7a9">http-interop/http-middleware 0.2.0</a>.
That version of the specification defines the following interfaces:</p>
<pre class="codehilite"><code class="language-php linenums">namespace Interop\Http\Middleware;

use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;

interface DelegateInterface
{
    public function process(RequestInterface $request) : ResponseInterface;
}

interface MiddlewareInterface
{
    public function process(RequestInterface $request, DelegateInterface $delegate) : ResponseInterface;
}

interface ServerMiddlewareInterface
{
    public function process(ServerRequestInterface $request, DelegateInterface $delegate) : ResponseInterface;
}</code></pre>

<p>The support in version 1.3.0 consists of the following:</p>
<ul>
<li><code>MiddlewarePipe</code> now also implements <code>ServerMiddlewareInterface</code>, and allows
  piping either type of http-interop middleware.</li>
<li><code>Next</code> now also implements <code>DelegateInterface</code>.</li>
<li><code>Dispatch</code> is now capable of dispatching either http-interop middleware type,
  in addition to legacy callable middleware.</li>
</ul>
<p>Additionally, <code>MiddlewarePipe</code> will now allow composing a <em>response prototype</em>;
this is a PSR-7 <code>ResponseInterface</code> instance. If not set, the first time the
pipeline is invoked via its <code>__invoke()</code> method, it will set the prototype from
the provided <code>$response</code> argument. When present, any callable, non-error
middleware piped to the pipeline will be wrapped in a
<code>Zend\Stratigility\Middleware\CallableMiddlewareWrapper</code> instance, which
converts it into an http-interop middleware type; when processed, the response
prototype will be passed to the callable for the response argument.</p>
<h3 id="http-middleware-041-and-stratigility-20">http-middleware 0.4.1 and Stratigility 2.0</h3>
<p>http-interop/http-middleware 0.4.1 introduces breaking changes in the
interfaces, including the following:</p>
<ul>
<li>
<p>The namespace changes from <code>Interop\Http\Middleware</code> to
  <code>Interop\Http\ServerMiddleware</code>, signaling a change indicating that the project
  now only targets server-side middleware.</p>
</li>
<li>
<p>The interface <code>ServerMiddlewareInterface</code> is now more simply
  <code>MiddlewareInterface</code>, as the namespace indicates its usage in server-side
  applications. <code>Interop\Http\Middleware\MiddlewareInterface</code>, which targeted
  client-side middleware, was removed entirely.</p>
</li>
<li>
<p>The method <code>DelegateInterface::process</code> now accepts specifically a
  <code>Psr\Http\Message\ServerRequestInterface</code>, and not the more general
  <code>RequestInterface</code>.</p>
</li>
</ul>
<p>The first two changes required only a change in import statements to
accommodate, and could have been imported in parallel to the 0.2.0 interfaces.
However, the second represents a signature change, which has necessitated a
major version bump in Stratigility in order to remain compatible.</p>
<p>Stratigility 2.0.0 therefor targets http-interop/http-middleware 0.4.1, and that
version (and compatible versions) only.</p>
<p>Additionally, starting in version 2.0.0, <code>MiddlewarePipe</code> <em>will no longer implement
<code>Zend\Stratigility\MiddlewareInterface</code>, and only implement the
http-interop/http-middleware <code>MiddlewareInterface</code></em>. This has several
repercussions.</p>
<h3 id="callable-middleware-in-version-130">Callable middleware in version 1.3.0</h3>
<p>Callable middleware can be used without change in version 1.3.0. However, we
recommend updating your code to prepare for version 2.0.0.</p>
<p>First, <strong>we recommend <em>never</em> using the <code>$response</code> argument provided to
middleware.</strong></p>
<p>The reason for this recommendation is two-fold. First, the http-interop/http-middleware
interfaces do not provide it, and, as such, using it within your middleware
makes your middleware incompatible. Second, and more importantly, is due to the
reason why http-interop does not include the argument: usage can lead to
inconsistent and/or unexpected results.</p>
<p>As an example, consider the following:</p>
<pre class="codehilite"><code class="language-php linenums">use Zend\Diactoros\Response\JsonResponse;

$pipeline-&gt;pipe(function ($request, $response, $next) {
    return $next($request, $response-&gt;withHeader('X-Foo', 'Bar'));
});

$pipeline-&gt;pipe(function ($request, $response, $next) {
    return new JsonResponse(['ack' =&gt; time()]);
});</code></pre>

<p>The first, outer layer of middleware sets a response header. However, the
second, inner middleware, <em>creates and returns an entirely new response</em>,
making the new header disappear.</p>
<p>As such, we recommend rewriting such middleware to modify the <em>returned</em>
response instead:</p>
<pre class="codehilite"><code class="language-php linenums">use Zend\Diactoros\Response\JsonResponse;

$pipeline-&gt;pipe(function ($request, $response, $next) {
    $response = $next($request, $response);
    return $response-&gt;withHeader('X-Foo', 'Bar');
});

$pipeline-&gt;pipe(function ($request, $response, $next) {
    return new JsonResponse(['ack' =&gt; time()]);
});</code></pre>

<p>The above will have the expected result for whatever middleware is nested
beneath it, as it will operate on the returned response, and have consistent
results.</p>
<p>Second, either wrap your middleware in <code>CallableMiddlewareWrapper</code>, or ensure
your pipeline composes a <em>response prototype</em> (doing so will implicitly
decorate callable middleware). Either of these will ensure your middleware will
work with http-interop/http-middleware delegators.</p>
<pre class="codehilite"><code class="language-php linenums">use Zend\Stratigility\Middleware\CallableMiddlewareWrapper;

// Manually decorating callable middleware for use with http-middleware:
$pipeline-&gt;pipe(new CallableMiddlewareWrapper($middleware, $response));

// Auto-decorate middleware by providing a response prototype:
$pipeline-&gt;setResponsePrototype($response);
$pipeline-&gt;pipe($middleware);</code></pre>

<blockquote>
<h3 id="callablemiddlewarewrapper-and-stratigility-20">CallableMiddlewareWrapper and Stratigility 2.0</h3>
<p>As noted above, version 2 of Stratigility is incompatible with version 1.3 due
to signature changes in the http-middleware project. However, if you wrap your
callable middleware using <code>CallableMiddlewareWrapper</code>, you will need to make
no changes in your application to make it forwards compatible.</p>
<p>We recommend using this strategy if you need to do a stepped transition to
Stratigility 2.0.</p>
</blockquote>
<p>Third, and optionally, you can make one or both of the following changes to
your callable middleware:</p>
<ul>
<li>Typehint the final <code>$next</code> argument against <code>Interop\Http\Middleware\DelegateInterface</code>;
  optionally, rename it to <code>$delegate</code>. This will require a slight change to
  how you invoke the next layer as well; see below.    </li>
<li>Remove the <code>$response</code> argument from your signature; if you do, make sure you
  typehint the delegate argument, and make it required.</li>
</ul>
<p>As an example of the first:</p>
<pre class="codehilite"><code class="language-php linenums">function ($request, $response, DelegateInterface $delegate) {
    $response = $delegate-&gt;process($request);
    return $response-&gt;withHeader('X-Foo', 'Bar');
}</code></pre>

<p>As an example of adopting both practices:</p>
<pre class="codehilite"><code class="language-php linenums">function ($request, DelegateInterface $delegate) {
    $response = $delegate-&gt;process($request);
    return $response-&gt;withHeader('X-Foo', 'Bar');
}</code></pre>

<p>At this point, you have essentially implemented <code>Interop\Http\Middleware\ServerMiddlewareInterface</code>
(with the notable exception of not type-hinting the <code>$request</code> argument).
When you pipe such callable middleware to <code>MiddlewarePipeline</code>, it will be
wrapped in a <code>Zend\Stratigility\Middleware\CallableInteropMiddlewareWrapper</code>,
which simply proxies to the middleware when processed.</p>
<blockquote>
<h3 id="delegateinterface-and-stratigility-20">DelegateInterface and Stratigility 2.0</h3>
<p>Since the namespace within http-interop/http-middleware changes between
version 0.2.0 and 0.4.1, the above strategy will require making changes
multiple times: once when upgrading to Stratigility 1.3, and another when
upgrading to 2.0. As such, we recommend instead decorating your callable
middleware using the <code>CallableMiddlewareWrapper</code>, until such time as you can
rewrite your middleware to implement the http-middleware 0.4.1 interfaces.</p>
</blockquote>
<p>Finally, if you are so inclined, you can rewrite your middleware to
specifically implement one or the other of the http-interop/http-middleware
interfaces. This is particularly relevant for class-based middleware, but can
also be accomplished by using PHP 7 anonymous classes.</p>
<p>As an example, consider the following middleware class:</p>
<pre class="codehilite"><code class="language-php linenums">use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;
use Zend\Diactoros\Response\JsonResponse;

class PingMiddleware
{
    public function __invoke(
        ServerRequestInterface $request,
        ResponseInterface $response,
        callable $next
    ) {
        return new JsonResponse(['ack' =&gt; time()]);
    }
}</code></pre>

<p>This could be rewritten as follows:</p>
<pre class="codehilite"><code class="language-php linenums">use Interop\Http\Middleware\DelegateInterface;
use Interop\Http\Middleware\ServerMiddlewareInterface;
use Psr\Http\Message\ServerRequestInterface;
use Zend\Diactoros\Response\JsonResponse;

class PingMiddleware implements ServerMiddlewareInterface
{
    public function process(ServerRequestInterface $request, DelegateInterface $delegate)
    {
        return new JsonResponse(['ack' =&gt; time()]);
    }
}</code></pre>

<p>If we were dealing with callable middleware instead:</p>
<pre class="codehilite"><code class="language-php linenums">use Zend\Diactoros\Response\JsonResponse;

$pipeline-&gt;pipe(function ($request, $response, $next) {
    return new JsonResponse(['ack' =&gt; time()]);
});</code></pre>

<p>we could wrap this in an anonymous class instead:</p>
<pre class="codehilite"><code class="language-php linenums">use Interop\Http\Middleware\DelegateInterface;
use Interop\Http\Middleware\ServerMiddlewareInterface;
use Psr\Http\Message\ServerRequestInterface;
use Zend\Diactoros\Response\JsonResponse;

$pipeline-&gt;pipe(new class implements ServerMiddlewareInterface {
    public function (ServerRequestInterface $request, DelegateInterface $delegate)
    {
        return new JsonResponse(['ack' =&gt; time()]);
    }
});</code></pre>

<blockquote>
<p>Using anonymous classes is likely overkill, as both v1.3.0 and v2.0.0 support
piping closures.</p>
</blockquote>
<p>If you want your middleware to work with either http-interop/http-middleware or
with the pre-1.3.0 middleware signature, you can do that as well. To accomplish
this, we provide <code>Zend\Stratigility\Delegate\CallableDelegateDecorator</code>, which
will wrap a <code>callable $next</code> such that it may be used as a <code>DelegateInterface</code>
implementation:</p>
<pre class="codehilite"><code class="language-php linenums">use Interop\Http\Middleware\DelegateInterface;
use Interop\Http\Middleware\ServerMiddlewareInterface;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;
use Zend\Diactoros\Response\JsonResponse;
use Zend\Stratigility\Delegate\CallableDelegateDecorator;

class PingMiddleware implements ServerMiddlewareInterface
{
    public function __invoke(
        ServerRequestInterface $request,
        ResponseInterface $response,
        callable $next
    ) {
        return $this-&gt;process($request, new CallableDelegateDecorator($next, $response));
    }

    public function process(ServerRequestInterface $request, DelegateInterface $delegate)
    {
        return new JsonResponse(['ack' =&gt; time()]);
    }
}</code></pre>

<blockquote>
<h3 id="implementing-http-interop-between-stratigility-13-and-20">Implementing http-interop between Stratigility 1.3 and 2.0</h3>
<p>While you <em>can</em> write your middleware to implement the
http-interop/http-middleware middleware interface, please be aware that if you
do so, you will need to take additional steps when upgrading from 1.3 to 2.0.</p>
<p>In most cases, you should be able to simply change the import statements
within your class file. As an example, if you have the following in your
Stratigility 1.3-based project:</p>
<pre class="codehilite"><code class="language-php linenums">use Interop\Http\Middleware\DelegateInterface;
use Interop\Http\Middleware\ServerMiddlewareInterface;</code></pre>

<p>The imports would become:</p>
<pre class="codehilite"><code class="language-php linenums">use Interop\Http\ServerMiddleware\DelegateInterface;
use Interop\Http\ServerMiddleware\MiddlewareInterface as ServerMiddlewareInterface;</code></pre>

</blockquote>
<p>To summarize:</p>
<ul>
<li>
<p>Never work with the provided <code>$response</code> argument, but instead manipulate the
  response returned from calling <code>$next</code>.</p>
</li>
<li>
<p>Ensure your pipeline can decorate callable middleware as http-interop/http-middleware.
  Do this by injecting a response prototype in the pipeline prior to piping any
  middleware. (<em>Note: this is not necessary if all callable middleware defines
  exactly two parameters, with the second type-hinting on the http-interop
  <code>DelegateInterface</code></em>.)</p>
</li>
<li>
<p>Consider adapting your callable middleware to follow the http-interop middleware
  signature (<code>function (ServerRequestInterface $request, DelegateInterface $delegate)</code>);
  this will make it forward-compatible. (Be aware that this may require changes
  in import statements between Stratigility 1.3 and 2.0.)</p>
</li>
<li>
<p>Consider updating your class-based middleware to implement the
  http-interop/http-middleware server middleware interface, potentially keeping
  the <code>__invoke()</code> method for interoperability with existing callable-based
  middleware runners. (Be aware that this may require changes in import
  statements between Stratigility
  1.3 and 2.0.)</p>
</li>
</ul>
<p>The first and last suggestions in this list are strongly recommended to ensure
forwards compatibility with http-middleware, and to ensure your middleware works
properly across middleware stacks.</p>
<h3 id="callable-middleware-in-version-200">Callable middleware in version 2.0.0</h3>
<p>Callable middleware may still be used; however, in order to pipe it to the
pipeline, you must do one of the following:</p>
<ul>
<li>
<p>Inject a <code>Zend\Stratigility\Middleware\CallableMiddlewareWrapperFactory</code>
  instance via the pipeline's <code>setCallableMiddlewareDecorator()</code> method,
  prior to piping callable middleware to the instance. This factory class
  requires a <code>ResponseInterface</code> in its constructor, and will use that
  response when creating <code>CallableMiddlewareWrapper</code> instances.</p>
<pre class="codehilite"><code class="language-php linenums">$factory = new CallableMiddlewareWrapperFactory(new Response());
$pipeline-&gt;setCallableMiddlewareDecorator($factory);</code></pre>

</li>
<li>
<p>Pass a response prototype before piping the callable middleware. If no
  <code>CallableMiddlewareWrapperFactory</code> is present, this prototype will be
  used to seed one for use with decorating callable middleware.</p>
<pre class="codehilite"><code class="language-php linenums">$pipeline-&gt;setResponsePrototype(new Response());</code></pre>

</li>
<li>
<p>Manually decorate your middleware prior to passing it to the pipeline:</p>
<pre class="codehilite"><code class="language-php linenums">$pipeline-&gt;pipe(new CallableMiddlewareWrapper($middleware, $response));
// or CallableInteropMiddlewareWrapper, if your middleware implements
// the http-middleware signature already.</code></pre>

</li>
</ul>
<h3 id="invoking-middlewarepipe-instances-in-version-200">Invoking MiddlewarePipe instances in version 2.0.0</h3>
<p>Invocation of the outermost middleware can now be done in two ways:</p>
<ul>
<li>Using <code>__invoke()</code>. This now requires a third argument, <code>$delegate</code>, which
  may be one of a <code>callable</code> accepting <code>ServerRequestInterface</code> and <code>ResponseInterface</code>
  arguments, or a <code>DelegateInterface</code> instance (the former will be decorated
  as the latter, binding the response instance). This will be invoked only
  if the <code>MiddlewarePipe</code>'s internal queue is exhausted without returning
  a response, and <strong>must</strong> return a response itself. A good candidate for this
  is the <code>NoopFinalHandler</code>.</li>
<li>Using <code>process()</code>. This argument requires a request and <code>DelegateInterface</code>
  instance; again, the <code>DelegateInterface</code> instance will only be invoked if
  the pipeline's internal queue is exhausted without returning a response.</li>
</ul>
<p>As examples:</p>
<pre class="codehilite"><code class="language-php linenums">use Zend\Stratigility\NoopFinalHandler;
use Zend\Stratigility\Delegate\CallableDelegateDecorator;

// Using __invoke():
$response = $pipeline($request, $response, new NoopFinalHandler());

// Using process():
$response = $pipeline-&gt;process($request, new CallableDelegateDecorator(
    new NoopFinalHandler(),
    $response
));</code></pre>

<p>Once you have done so, you can process the returned request via an
<a href="https://docs.zendframework.com/zend-diactoros/emitting-responses/">emitter</a>.</p>
<h2 id="deprecated-functionality">Deprecated functionality</h2>
<p>The following classes, methods, and arguments are deprecated starting in version
1.3.0, and will be removed in version 2.0.0.</p>
<ul>
<li><code>Zend\Stratigility\FinalHandler</code> (class)</li>
<li><code>Zend\Stratigility\Dispatch</code> (class); this class is marked internal already,
  but anybody extending <code>Next</code> and/or this class should be aware of its removal.</li>
<li><code>Zend\Stratigility\ErrorMiddlewareInterface</code> (interface); error middleware
  should now be implemented per the <a href="#error-handling">error handling section above</a>.</li>
<li>The <code>$response</code> argument to <code>Zend\Stratigility\Next</code>'s <code>__invoke()</code> method.
  The argument, and all following it, are ignored starting in 2.0.0; it is used
  in 1.3.0 to ensure backwards compatibility with existing middleware. The
  <code>CallableMiddlewareWrapper</code> also ensures that a response argument is populated
  and present when invoking callable middleware.</li>
<li>The <code>$err</code> argument to <code>Zend\Stratigility\Next</code>'s <code>__invoke()</code> method.
  Starting in 1.3.0, if a non-null value is encountered, this method will now
  emit an <code>E_USER_DEPRECATED</code> notice, referencing this documentation.</li>
<li><code>Zend\Stratigility\Http\Request</code> (class)</li>
<li><code>Zend\Stratigility\Http\ResponseInterface</code> (interface)</li>
<li><code>Zend\Stratigility\Http\Response</code> (class)</li>
</ul>
<h2 id="interfacesignature-changes">Interface/signature changes</h2>
<p>The following signature changes were made with the 2.0.0 release:</p>
<ul>
<li><code>Zend\Stratigility\Next</code>:</li>
<li>The <code>$done</code> constructor argument was renamed to <code>$nextDelegate</code>, and now
    allows either <code>callable</code> or <code>Interop\Http\ServerMiddleware\DelegateInterface</code>
    arguments.</li>
<li>The <code>$response</code> argument to <code>__invoke()</code> was removed.</li>
<li>The (optional) <code>$err</code> argument to <code>__invoke()</code> was removed.</li>
</ul>
<h2 id="removed-functionality">Removed functionality</h2>
<p>The following classes, methods, and arguments are removed starting in version
2.0.0.</p>
<ul>
<li><code>Zend\Stratigility\Dispatch</code> (class)</li>
<li><code>Zend\Stratigility\ErrorMiddlewareInterface</code> (class)</li>
<li><code>Zend\Stratigility\FinalHandler</code> (class)</li>
<li><code>Zend\Stratigility\MiddlewareInterface</code>. Define your middleware as callables,
  or using http-interop/http-middleware interfaces instead.</li>
<li><code>Zend\Stratigility\Utils::getArity()</code> (static method); no longer used
  internally.</li>
<li>The <code>$err</code> argument to <code>Zend\Stratigility\Next</code>'s <code>__invoke()</code> method. If
  passed, it will now be ignored.</li>
<li><code>Zend\Stratigility\Http\Request</code> (class)</li>
<li><code>Zend\Stratigility\Http\ResponseInterface</code> (interface)</li>
<li><code>Zend\Stratigility\Http\Response</code> (class)</li>
<li>The <code>$response</code> argument to middleware is deprecated; please see the
  <a href="../callable-middleware-in-version-1.3.0">section on callable middleware</a>
  for details, and adapt your middleware to no longer use the argument.
  While the legacy callable signature will continue to work, we recommend
  implementing an http-interop/http-middleware interface.</li>
</ul>

<hr />


<nav>
  <ul class="pager hidden-print">
    <li class="previous">
      <a rel="prev" href="../../api/"><i class="fa fa-arrow-left"></i> Previous</a>
    </li>
    <li class="next disabled ">
      <a rel="next" >Next <i class="fa fa-arrow-right"></i></a>
    </li>
  </ul>
</nav>
</div>
        
    </div>
    <!-- content:end -->

    <div id="footerwrap">
    <div class="container">
        <div class="row site-map">
            <div class="col-lg-3">
              <p>
                <strong>Zend Framework</strong><br />
                <a href="http://framework.zend.com/">framework.zend.com</a><br />
                <a href="https://docs.zendframework.com">docs.zendframework.com</a><br />
                <a href="https://packages.zendframework.com">packages.zendframework.com</a><br />
                <a href="https://apigility.org">apigility.org</a><br />
              </p>
            </div>
        </div>

        <div class="row">
            <div class="col-lg-12 centered">
                <a class="back-to-top" href="#page-top"><i class="fa fa-chevron-circle-up fa-4" aria-hidden="true"></i></a>
            </div>
        </div>

        <div class="spacing"></div>

        <div class="row">
            <div class="col-lg-8">
                <h4>Copyright</h4>
                <div class="hline-w"></div>

                <p>&copy; 2006-2016 by <a href="http://www.zend.com">Zend</a>, a <a href="http://www.roguewave.com/">Rogue Wave Company</a>.</p>
            </div>

            <div class="col-lg-4">
                <h4>Contacts</h4>
                <div class="hline-w"></div>
                <p>
                    <a href="irc://irc.freenode.net/zftalk" class="btn-social btn-outline" alt="IRC" title="IRC"><i class="fa fa-comment"></i></a>
                    <a href="https://github.com/zendframework" class="btn-social btn-outline" alt="Github" title="Github"><i class="fa fa-github"></i></a>
                    <a href="https://twitter.com/zfdevteam" class="btn-social btn-outline" alt="Twitter" title="Twitter"><i class="fa fa-twitter"></i></a>
                </p>
            </div>
        </div>
    </div>
</div>


    <script src="../../js/jquery-1.10.2.min.js"></script>
    <script src="../../js/bootstrap-3.0.3.min.js"></script>
    <script src="../../js/prism-zf.js"></script>

    <script>var base_url = '../..';</script>
    <script data-main="../../mkdocs/js/search.js" src="../../mkdocs/js/require.js"></script>
    <script src="../../js/base.js"></script>

    <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <button type="button" class="close" data-dismiss="modal">
                        <span aria-hidden="true">&times;</span>
                        <span class="sr-only">Close</span>
                    </button>
                    <h4 class="modal-title" id="exampleModalLabel">Search</h4>
                </div>
                <div class="modal-body">
                    <p>
                        From here you can search these documents. Enter your search terms below.
                    </p>
                    <form role="form">
                        <div class="form-group">
                            <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query">
                        </div>
                    </form>
                    <div id="mkdocs-search-results"></div>
                </div>
                <div class="modal-footer">
                </div>
            </div>
        </div>
    </div>

    <div class="zf-components">
  <div class="zf-components-grid">
    <div class="zf-logo">
      <a href="http://framework.zend.com" data-toggle="tooltip" data-placement="bottom" title="Go to the ZF homepage"><img src="../../img/zf-logo-mark.svg" alt="Zend Framework" width="250" /></a>
    </div>

    <div class="component-list"></div>

    <p class="zf-components-rollup"><a href="#">Hide list</a></p>
  </div>
</div>

    <script>
  // Prepare the component list dropdown for display
  $(function () {
    var components = $(".zf-components"),
        componentList = components.find(".component-list"),
        sidebar = $(".bs-sidebar.affix"),
        sidebarInitialPos = sidebar.css("position"),
        hidden,
        componentToggle = $(".component-toggle"),
        navbar = $(".navbar-fixed-top"),
        rollUpLink = $(".zf-components-rollup a");

    // Initial setup on document load
    components.insertBefore(navbar);
    $(".zf-logo a").tooltip();
    componentToggle.tooltip();
    rollUpLink.attr({ href: "#", alt: "Hide component list" });

    // Cast initial sidebar position value
    if (undefined === sidebarInitialPos) {
      sidebarInitialPos = "fixed";
    }

    // Setup onclick events to toggle list
    componentToggle.click(toggleComponentList);
    rollUpLink.click(toggleComponentList);

    // Toggle the component list display
    function toggleComponentList(event) {
      event.preventDefault();

      if (hidden === undefined) {
        // Not loaded yet; load and display.
        loadComponentList();
        return;
      }

      if (hidden) {
        // Hidden; display.
        showComponentList();
        return;
      }

      // Currently visible; hide
      hideComponentList();
    }

    // Show the component list
    function showComponentList() {
      navbar.css({position: "relative"});
      sidebar.css({position: "relative"});
      components
        .css({"margin-top": "-" + components.outerHeight() + "px"})
        .show()
        .animate({"margin-top": 0}, {
          complete: function () {
            componentToggle
              .data("placement", "top")
              .attr("data-original-title", "Hide component list");
            hidden = false;
          },
          queue: false
        });
    }

    // Hide the component list
    function hideComponentList() {
      components.animate({"margin-top": "-" + components.outerHeight() + "px"}, {
        complete: function () {
          navbar.css({position: "fixed"});
          sidebar.css({position: sidebarInitialPos});
          componentToggle
            .data("placement", "bottom")
            .attr("data-original-title", "Show component list");
          components.hide();
          hidden = true;
        },
        queue: false
      });
      sidebar.animate({ top: sidebarInitialTop + "px" }, { queue: false});
    }

    // Inject a component into the componet list DOM.
    function injectComponent(index, component) {
      componentList.append('<div class="component"><h4><a href="' + component.url + '">' + component.name + '</a></h4><p>' + component.description + '</p></div>');
    }

    // Parse the component list, build the DOM, and display it.
    function parseComponentList(components) {
      $.each(components, injectComponent);
      showComponentList();
    }

    // Fetch the component list and display it.
    function loadComponentList () {
      $.ajax({
        url: "//docs.zendframework.com/zf-mkdoc-theme/scripts/zf-component-list.json",
        dataType: "text json",
        success: parseComponentList,
        error: function (e) {
          console.log("Error occurred with XHR call", e);
        }
      });
    }
  });
</script>
    </body>

</html>
