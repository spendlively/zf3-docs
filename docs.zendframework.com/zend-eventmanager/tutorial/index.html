<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">  
    <link rel="shortcut icon" href="../img/favicon.ico">

    <title>Tutorial - zend-eventmanager</title>

    <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css" rel="stylesheet">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/font-hack/2.018/css/hack.min.css">
    <link href="//fonts.googleapis.com/css?family=PT+Sans:400,400italic,700,700italic&subset=latin-ext,latin" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,700italic,400,300,600,700&subset=latin-ext,latin" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Libre+Baskerville:400,400italic,700&subset=latin,latin-ext" rel="stylesheet" type="text/css">
    <link href="../css/base.css" rel="stylesheet">
    <link href="../css/zf.css" rel="stylesheet">
    <link href="../css/prism-zf.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

    <script src="https://ajax.googleapis.com/ajax/libs/webfont/1.5.18/webfont.js"></script>
    <script>
    WebFont.load({
        google: {
            families: ['Open Sans', 'PT Sans']
        }
    });
    </script>

    
</head>

<body>

    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            

            <!-- Main title -->
            <span class="navbar-brand">
              <a class="logo-link" href="http://framework.zend.com" data-toggle="tooltip" data-placement="bottom" title="Zend Framework"><img src="../img/zf-logo-mark.png" height="28" alt="Zend Framework" /></a>
              <a href="..">zend-eventmanager</a>
            </span>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                
                
                    <li >
                        <a href="..">Home</a>
                    </li>
                
                
                
                    <li >
                        <a href="../intro/">Intro</a>
                    </li>
                
                
                
                    <li >
                        <a href="../quick-start/">Quick Start</a>
                    </li>
                
                
                
                    <li class="active">
                        <a href="./">Tutorial</a>
                    </li>
                
                
                
                    <li >
                        <a href="../examples/">Examples</a>
                    </li>
                
                
                
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Reference <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li >
    <a href="../wildcard-listeners/">Wildcard Listeners</a>
</li>

                        
                            
<li >
    <a href="../aggregates/">Listener Aggregates</a>
</li>

                        
                            
  <li class="dropdown-submenu">
    <a tabindex="-1" href="">Lazy Listeners</a>
    <ul class="dropdown-menu">
        
            
<li >
    <a href="../lazy-listeners/intro/">Intro</a>
</li>

        
            
<li >
    <a href="../lazy-listeners/lazy-listener/">LazyListener</a>
</li>

        
            
<li >
    <a href="../lazy-listeners/lazy-event-listener/">LazyEventListener</a>
</li>

        
            
<li >
    <a href="../lazy-listeners/lazy-listener-aggregate/">LazyListenerAggregate</a>
</li>

        
    </ul>
  </li>

                        
                            
<li >
    <a href="../api/">EventManager API</a>
</li>

                        
                            
<li >
    <a href="../intercepting-filters/">Intercepting Filters</a>
</li>

                        
                            
  <li class="dropdown-submenu">
    <a tabindex="-1" href="">Migration Guide</a>
    <ul class="dropdown-menu">
        
            
<li >
    <a href="../migration/intro/">Intro</a>
</li>

        
            
<li >
    <a href="../migration/removed/">Removed Functionality</a>
</li>

        
            
<li >
    <a href="../migration/changed/">Changed Functionality</a>
</li>

        
    </ul>
  </li>

                        
                        </ul>
                    </li>
                
                
                </ul>
            

            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="#" class="component-toggle" data-toggle="tooltip" data-placement="bottom" title="Show component list">
                        <i class="fa fa-book"></i> Components
                    </a>
                </li>

                <li>
                    <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                        <i class="fa fa-search"></i> Search
                    </a>
                </li>
                
                    <li>
                        <a href="https://github.com/zendframework/zend-eventmanager">
                            
                                <i class="fa fa-github"></i>
                            
                            GitHub
                        </a>
                    </li>
                
            </ul>
        </div>
    </div>
</div>

    <!-- content:begin -->
    <div class="container">
        
        <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#tutorial">Tutorial</a></li>
        
            <li><a href="#terminology">Terminology</a></li>
        
            <li><a href="#getting-started">Getting started</a></li>
        
            <li><a href="#shared-managers">Shared managers</a></li>
        
            <li><a href="#wildcards">Wildcards</a></li>
        
            <li><a href="#listener-aggregates">Listener aggregates</a></li>
        
            <li><a href="#introspecting-results">Introspecting results</a></li>
        
            <li><a href="#short-circuiting-listener-execution">Short-circuiting listener execution</a></li>
        
            <li><a href="#keeping-it-in-order">Keeping it in order</a></li>
        
            <li><a href="#custom-event-objects">Custom event objects</a></li>
        
            <li><a href="#putting-it-together-implementing-a-simple-caching-system">Putting it together: Implementing a simple caching system</a></li>
        
            <li><a href="#conclusion">Conclusion</a></li>
        
    
    </ul>

    
    <ul class="pager hidden-print">
      <li class="previous">
        <a rel="prev" href="../quick-start/"><i class="fa fa-arrow-left"></i> Previous</a>
      </li>
      <li class="next">
        <a rel="next" href="../examples/">Next <i class="fa fa-arrow-right"></i></a>
      </li>
    </ul>
    
</div></div>
        <div class="col-md-9" role="main">

<ol class="breadcrumb" role="navigation" aria-label="breadcrumbs navigation">
  <li><a href="..">Docs</a> &raquo;</li>
  
    
  
  <li class="active">Tutorial</li>
</ol>

<h1 id="tutorial">Tutorial</h1>
<p>This tutorial explores the various features of zend-eventmanager.</p>
<h2 id="terminology">Terminology</h2>
<ul>
<li>An <strong>Event</strong> is a named action.</li>
<li>A <strong>Listener</strong> is any PHP callback that reacts to an <em>event</em>.</li>
<li>An <strong>EventManager</strong> <em>aggregates</em> listeners for one or more named events, and <em>triggers</em> events.</li>
</ul>
<p>Typically, an <em>event</em> will be modeled as an object, containing metadata
surrounding when and how it was triggered, including the event name, what object
triggered the event (the "target"), and what parameters were provided. Events
are <em>named</em>, which allows a single <em>listener</em> to branch logic based on the
event.</p>
<h2 id="getting-started">Getting started</h2>
<p>The minimal things necessary to start using events are:</p>
<ul>
<li>An <code>EventManager</code> instance</li>
<li>One or more listeners on one or more events</li>
<li>A call to <code>trigger()</code> an event</li>
</ul>
<p>The simplest example looks something like this:</p>
<pre class="codehilite"><code class="language-php linenums">use Zend\EventManager\EventManager;

$events = new EventManager();
$events-&gt;attach('do', function ($e) {
    $event = $e-&gt;getName();
    $params = $e-&gt;getParams();
    printf(
        'Handled event &quot;%s&quot;, with parameters %s',
        $event,
        json_encode($params)
    );
});

$params = ['foo' =&gt; 'bar', 'baz' =&gt; 'bat'];
$events-&gt;trigger('do', null, $params);</code></pre>

<p>The above will result in the following:</p>
<pre class="codehilite"><code class="language-text linenums">Handled event &quot;do&quot;, with parameters {&quot;foo&quot;:&quot;bar&quot;,&quot;baz&quot;:&quot;bat&quot;}</code></pre>

<blockquote>
<h3 id="note">Note</h3>
<p>Throughout this tutorial, we use closures as listeners. However, any valid PHP
callback can be attached as a listeners: PHP function names, static class
methods, object instance methods, functors, or closures. We use closures
within this post simply for illustration and simplicity.</p>
</blockquote>
<p>If you were paying attention to the example, you will have noted the <code>null</code>
argument. Why is it there?</p>
<p>Typically, you will compose an <code>EventManager</code> within a class, to allow
triggering actions within methods. The middle argument to <code>trigger()</code> is the
"target", and in the case described, would be the current object instance. This
gives event listeners access to the calling object, which can often be useful.</p>
<pre class="codehilite"><code class="language-php linenums">use Zend\EventManager\EventManager;
use Zend\EventManager\EventManagerAwareInterface;
use Zend\EventManager\EventManagerInterface;

class Example implements EventManagerAwareInterface
{
    protected $events;

    public function setEventManager(EventManagerInterface $events)
    {
        $events-&gt;setIdentifiers([
            __CLASS__,
            get_class($this)
        ]);
        $this-&gt;events = $events;
    }

    public function getEventManager()
    {
        if (! $this-&gt;events) {
            $this-&gt;setEventManager(new EventManager());
        }
        return $this-&gt;events;
    }

    public function doIt($foo, $baz)
    {
        $params = compact('foo', 'baz');
        $this-&gt;getEventManager()-&gt;trigger(__FUNCTION__, $this, $params);
    }

}

$example = new Example();

$example-&gt;getEventManager()-&gt;attach('doIt', function($e) {
    $event  = $e-&gt;getName();
    $target = get_class($e-&gt;getTarget()); // &quot;Example&quot;
    $params = $e-&gt;getParams();
    printf(
        'Handled event &quot;%s&quot; on target &quot;%s&quot;, with parameters %s',
        $event,
        $target,
        json_encode($params)
    );
});

$example-&gt;doIt('bar', 'bat');</code></pre>

<p>The above is basically the same as the first example. The main difference is
that we're now using that middle argument in order to pass the target, the
instance of <code>Example</code>, on to the listeners. Our listener is now retrieving that
(<code>$e-&gt;getTarget()</code>), and doing something with it.</p>
<p>If you're reading this critically, you should have a new question: What is the
call to <code>setIdentifiers()</code> for?</p>
<h2 id="shared-managers">Shared managers</h2>
<p>One aspect that the <code>EventManager</code> implementation provides is an ability to
compose a <code>SharedEventManagerInterface</code> implementation.</p>
<p><code>Zend\EventManager\SharedEventManagerInterface</code> describes an object that
aggregates listeners for events attached to objects with specific <em>identifiers</em>.
It does not trigger events itself. Instead, an <code>EventManager</code> instance that
composes a <code>SharedEventManager</code> will query the <code>SharedEventManager</code> for
listeners on identifiers it's interested in, and trigger those listeners as
well.</p>
<p>How does this work, exactly?</p>
<p>Consider the following:</p>
<pre class="codehilite"><code class="language-php linenums">use Zend\EventManager\SharedEventManager;

$sharedEvents = new SharedEventManager();
$sharedEvents-&gt;attach('Example', 'do', function ($e) {
    $event  = $e-&gt;getName();
    $target = get_class($e-&gt;getTarget()); // &quot;Example&quot;
    $params = $e-&gt;getParams();
    printf(
        'Handled event &quot;%s&quot; on target &quot;%s&quot;, with parameters %s',
        $event,
        $target,
        json_encode($params)
    );
});</code></pre>

<p>This looks almost identical to the previous example; the key difference is that
there is an additional argument at the <em>start</em> of the list, <code>Example</code>. This
code is basically saying, "Listen to the 'do' event of the 'Example' target,
and, when notified, execute this callback."</p>
<p>This is where the <code>setIdentifiers()</code> method of <code>EventManager</code> comes into play.
The method allows passing an array of strings, defining the names of the context
or targets the given instance will be interested in.</p>
<p>So, getting back to our example, let's assume that the above shared listener is
registered, and also that the <code>Example</code> class is defined as above. (Note that as of 
version 3, <code>setSharedManager()</code> is removed from  <code>EventManager</code>; the <code>SharedEventManager</code> 
instance must instead be injected via the constructor.) We can then execute the following:</p>
<pre class="codehilite"><code class="language-php linenums">$example = new Example();

// Prior to version 3:
$example-&gt;getEventManager()-&gt;setSharedManager($sharedEvents);

// As of version 3:
$example-&gt;setEventManager(new EventManager($sharedEvents));

// Both versions:
$example-&gt;doIt('bar', 'bat');</code></pre>

<p>and expect the following output:</p>
<pre class="codehilite"><code class="language-text linenums">Handled event &quot;do&quot; on target &quot;Example&quot;, with parameters {&quot;foo&quot;:&quot;bar&quot;,&quot;baz&quot;:&quot;bat&quot;}</code></pre>

<p>Now, let's say we extended <code>Example</code> as follows:</p>
<pre class="codehilite"><code class="language-php linenums">class SubExample extends Example
{
}</code></pre>

<p>One interesting aspect of our <code>setEventManager()</code> method is that we defined it
to listen both on <code>__CLASS__</code> and <code>get_class($this)</code>. This means that calling
<code>do()</code> on our <code>SubExample</code> class would also trigger the shared listener! It also
means that, if desired, we could attach to specifically <code>SubExample</code>, and
listeners attached to only the <code>Example</code> target would not be triggered.</p>
<p>Finally, the names used as contexts or targets need not be class names; they can
be some name that only has meaning in your application if desired. As an
example, you could have a set of classes that respond to "log" or "cache" — and
listeners on these would be notified by any of them.</p>
<blockquote>
<h3 id="note_1">Note</h3>
<p>We recommend using class names, interface names, and/or abstract class names
for identifiers. This makes determining what events are available easier, as
well as finding which listeners might be attaching to those events. Interfaces
make a particularly good use case, as they allow attaching to a group of
related classes a single operation.</p>
</blockquote>
<h2 id="wildcards">Wildcards</h2>
<p>So far, with both a normal <code>EventManager</code> instance and with the
<code>SharedEventManager</code> instance, we've seen the usage of singular strings
representing the event and target names to which we want to attach. What if you
want to attach a listener to multiple events or targets?</p>
<p>One answer is to attach to the event manager using the wildcard event, <code>*</code>.</p>
<p>Consider the following examples:</p>
<pre class="codehilite"><code class="language-php linenums">$events-&gt;attach(
    '*', // all events
    $listener
);

// All targets via wildcard
$sharedEvents-&gt;attach(
    '*',           // all targets
    'doSomething', // named event
    $listener
);

// Mix and match: all events on a single named target:
$sharedEvents-&gt;attach(
    'Foo', // target
    '*',   // all events
    $listener
);

// Mix and match: all events on all targets:
$sharedEvents-&gt;attach(
    '*', // all targets
    '*', // all events
    $listener
);</code></pre>

<p>The ability to specify wildcard targets and/or events when attaching can slim
down your code immensely.</p>
<h2 id="listener-aggregates">Listener aggregates</h2>
<p>Another approach to listening to multiple events is via a concept of listener
aggregates, represented by <code>Zend\EventManager\ListenerAggregateInterface</code>. Via
this approach, a single class can listen to multiple events, attaching one or
more instance methods as listeners.</p>
<p>This interface defines two methods, <code>attach(EventManagerInterface $events)</code> and
<code>detach(EventManagerInterface $events)</code>. Basically, you pass an <code>EventManager</code>
instance to one and/or the other, and then it's up to the implementing class to
determine what to do.</p>
<p>As an example:</p>
<pre class="codehilite"><code class="language-php linenums">use Zend\EventManager\EventInterface;
use Zend\EventManager\EventManagerInterface;
use Zend\EventManager\ListenerAggregateInterface;
use Zend\Log\Logger;

class LogEvents implements ListenerAggregateInterface
{
    private $listeners = [];
    private $log;

    public function __construct(Logger $log)
    {
        $this-&gt;log = $log;
    }

    public function attach(EventManagerInterface $events)
    {
        $this-&gt;listeners[] = $events-&gt;attach('do', [$this, 'log']);
        $this-&gt;listeners[] = $events-&gt;attach('doSomethingElse', [$this, 'log']);
    }

    public function detach(EventCollection $events)
    {
        foreach ($this-&gt;listeners as $index =&gt; $listener) {
            $events-&gt;detach($listener);
            unset($this-&gt;listeners[$index]);
        }
    }

    public function log(EventInterface $e)
    {
        $event  = $e-&gt;getName();
        $params = $e-&gt;getParams();
        $this-&gt;log-&gt;info(sprintf('%s: %s', $event, json_encode($params)));
    }
}</code></pre>

<blockquote>
<h3 id="note_2">Note</h3>
<p>The trait <code>Zend\EventManager\ListenerAggregateTrait</code> can be composed to help
implement <code>ListenerAggregateInterface</code>; it defines the <code>$listeners</code> property,
and the <code>detach()</code> logic as demostrated above.</p>
</blockquote>
<p>You can attach this by passing the event manager to the aggregate's <code>attach()</code>
method:</p>
<pre class="codehilite"><code class="language-php linenums">$logListener = new LogEvents($logger);
$logListener-&gt;attach($events);</code></pre>

<p>Any events the aggregate attaches to will then be notified when triggered.</p>
<p>Why bother? For a couple of reasons:</p>
<ul>
<li>Aggregates allow you to have stateful listeners. The above example
  demonstrates this via the composition of the logger; another example would be
  tracking configuration options.</li>
<li>Aggregates allow grouping related listeners in a single class, and attaching
  them at once.</li>
</ul>
<h2 id="introspecting-results">Introspecting results</h2>
<p>Sometimes you'll want to know what your listeners returned. One thing to
remember is that you may have multiple listeners on the same event; the
interface for results must be consistent regardless of the number of listeners.</p>
<p>The <code>EventManager</code> implementation by default returns a
<code>Zend\EventManager\ResponseCollection</code> instance. This class extends PHP's
<code>SplStack</code>, allowing you to loop through responses in reverse order (since the
last one executed is likely the one you're most interested in). It also
implements the following methods:</p>
<ul>
<li><code>first()</code> will retrieve the first result received</li>
<li><code>last()</code> will retrieve the last result received</li>
<li><code>contains($value)</code> allows you to test all values to see if a given one was
  received, and returns simply a boolean <code>true</code> if found, and <code>false</code> if not.</li>
</ul>
<p>Typically, you should not worry about the return values from events, as the
object triggering the event shouldn't really have much insight into what
listeners are attached. However, sometimes you may want to short-circuit
execution if interesting results are obtained.</p>
<h2 id="short-circuiting-listener-execution">Short-circuiting listener execution</h2>
<p>You may want to short-ciruit execution if a particular result is obtained, or if
a listener determines that something is wrong, or that it can return something
quicker than the target.</p>
<p>As examples, one rationale for adding an <code>EventManager</code> is as a caching
mechanism. You can trigger one event early in the method, returning if a cache
is found, and trigger another event late in the method, seeding the cache.</p>
<p>The <code>EventManager</code> component offers two ways to handle this. The first is to
use the methods <code>triggerUntil()</code> or <code>triggerEventUntil()</code>. These accept a
callback as their first argument; if that callback returns a boolean <code>true</code>
value, execution is halted.</p>
<p>As an example:</p>
<pre class="codehilite"><code class="language-php linenums">public function someExpensiveCall($criteria1, $criteria2)
{
    $params  = compact('criteria1', 'criteria2');
    $results = $this-&gt;getEventManager()-&gt;triggerUntil(
        function ($r) {
            return ($r instanceof SomeResultClass);
        },
        __FUNCTION__, 
        $this, 
        $params
    );

    if ($results-&gt;stopped()) {
        return $results-&gt;last();
    }

    // ... do some work ...
}</code></pre>

<p>With this paradigm, we know that the likely reason of execution halting is due
to the last result meeting the test callback criteria; as such, we simply return
that last result.</p>
<p>The other way to halt execution is within a listener, acting on the <code>Event</code>
object it receives. In this case, the listener calls <code>stopPropagation(true)</code>,
and the <code>EventManager</code> will then return without notifying any additional
listeners.</p>
<pre class="codehilite"><code class="language-php linenums">$events-&gt;attach('do', function ($e) {
    $e-&gt;stopPropagation();
    return new SomeResultClass();
});</code></pre>

<p>This, of course, raises some ambiguity when using the trigger paradigm, as you
can no longer be certain that the last result meets the criteria it's searching
on. As such, we recommend that you standardize on one approach or the other.</p>
<h2 id="keeping-it-in-order">Keeping it in order</h2>
<p>On occasion, you may be concerned about the order in which listeners execute. As
an example, you may want to do any logging early, to ensure that if
short-circuiting occurs, you've logged; or if implementing a cache, you may want
to return early if a cache hit is found, and execute late when saving to a
cache.</p>
<p>Each of <code>EventManager::attach()</code> and <code>SharedEventManager::attach()</code> accept one
additional argument, a <em>priority</em>. By default, if this is omitted, listeners get
a priority of 1, and are executed in the order in which they are attached.
However, if you provide a priority value, you can influence order of execution.</p>
<ul>
<li>Higher priority values execute <em>earlier</em>.</li>
<li>Lower (negative) priority values execute <em>later</em>.</li>
</ul>
<p>To borrow an example from earlier:</p>
<pre class="codehilite"><code class="language-php linenums">$priority = 100;
$events-&gt;attach('Example', 'do', function($e) {
    $event  = $e-&gt;getName();
    $target = get_class($e-&gt;getTarget()); // &quot;Example&quot;
    $params = $e-&gt;getParams();
    printf(
        'Handled event &quot;%s&quot; on target &quot;%s&quot;, with parameters %s',
        $event,
        $target,
        json_encode($params)
    );
}, $priority);</code></pre>

<p>This would execute with high priority, meaning it would execute early. If we
changed <code>$priority</code> to <code>-100</code>, it would execute with low priority, executing
late.</p>
<p>While you can't necessarily know all the listeners attached, chances are you can
make adequate guesses when necessary in order to set appropriate priority
values. We advise avoiding setting a priority value unless absolutely necessary.</p>
<h2 id="custom-event-objects">Custom event objects</h2>
<p>Hopefully some of you have been wondering, "where and when is the <code>Event</code> object
created"? In all of the examples above, it's created based on the arguments
passed to <code>trigger()</code> — the event name, target, and parameters. Sometimes,
however, you may want greater control over the object.</p>
<p>As an example, one thing that looks like a code smell is when you have code like
this:</p>
<pre class="codehilite"><code class="language-php linenums">$routeMatch = $e-&gt;getParam('route-match', false);
if ( !$routeMatch) {
    // Oh noes! we cannot do our work! whatever shall we do?!?!?!
}</code></pre>

<p>The problems with this are several. First, relying on string keys is going to
very quickly run into problems — typos when setting or retrieving the argument
can lead to hard to debug situations. Second, we now have a documentation issue;
how do we document expected arguments? how do we document what we're shoving
into the event? Third, as a side effect, we can't use IDE or editor hinting
support — string keys give these tools nothing to work with.</p>
<p>Similarly, consider how you might represent a computational result of a method
when triggering an event. As an example:</p>
<pre class="codehilite"><code class="language-php linenums">// in the method:
$params['__RESULT'] = $computedResult;
$events-&gt;trigger(__FUNCTION__ . '.post', $this, $params);

// in the listener:
$result = $e-&gt;getParam('__RESULT__');
if (! $result) {
    // Oh noes! we cannot do our work! whatever shall we do?!?!?!
}</code></pre>

<p>Sure, that key may be unique, but it suffers from a lot of the same issues.</p>
<p>So, the solution is to create custom events. As an example, we have a custom
<code>MvcEvent</code> in zend-mvc. This event composes the application instance,
the router, the route match object, request and response objects, the view
model, and also a result. We end up with code like this in our listeners:</p>
<pre class="codehilite"><code class="language-php linenums">$response = $e-&gt;getResponse();
$result   = $e-&gt;getResult();
if (is_string($result)) {
    $content = $view-&gt;render('layout.phtml', ['content' =&gt; $result]);
    $response-&gt;setContent($content);
}</code></pre>

<p>But how do we use this custom event? Simple: the method <code>triggerEvent()</code>.</p>
<pre class="codehilite"><code class="language-php linenums">$event = new CustomEvent();
$event-&gt;setName('foo');
$event-&gt;setTarget($this);
$event-&gt;setSomeKey($value);

// Injected with event name and target:
$events-&gt;triggerEvent($event);

// Use triggerEventUntil() for criteria-based short-circuiting:
$results = $events-&gt;triggerEventUntil($callback, $event);</code></pre>

<p>This is a really powerful technique for domain-specific event systems, and
definitely worth experimenting with.</p>
<h2 id="putting-it-together-implementing-a-simple-caching-system">Putting it together: Implementing a simple caching system</h2>
<p>In previous sections, I indicated that short-circuiting is a way to potentially
implement a caching solution. Let's create a full example.</p>
<p>First, let's define a method that could use caching. You'll note that in most of
the examples, I've used <code>__FUNCTION__</code> as the event name; this is a good
practice, as it makes it simple to create a macro for triggering events, as well
as helps to keep event names unique (as they're usually within the context of
the triggering class). However, in the case of a caching example, this would
lead to identical events being triggered. As such, I recommend postfixing the
event name with semantic names: "do.pre", "do.post", "do.error", etc. I'll use
that convention in this example.</p>
<p>Additionally, you'll notice that the <code>$params</code> I pass to the event is usually
the list of parameters passed to the method. This is because those are often not
stored in the object, and also to ensure the listeners have the exact same
context as the calling method. But it raises an interesting problem in this
example: what name do we give the result of the method? One standard that has
emerged is the use of <code>__RESULT__</code>, as double-underscored variables are
typically reserved for the sytem.</p>
<p>Here's what the method will look like:</p>
<pre class="codehilite"><code class="language-php linenums">public function someExpensiveCall($criteria1, $criteria2)
{
    $params  = compact('criteria1', 'criteria2');
    $results = $this-&gt;getEventManager()-&gt;triggerUntil(
        function ($r) {
            return ($r instanceof SomeResultClass);
        },
        __FUNCTION__ . '.pre',
        $this,
        $params
    );

    if ($results-&gt;stopped()) {
        return $results-&gt;last();
    }

    // ... do some work ...

    $params['__RESULT__'] = $calculatedResult;
    $this-&gt;events()-&gt;trigger(__FUNCTION__ . '.post', $this, $params);
    return $calculatedResult;
}</code></pre>

<p>Now, to provide some caching listeners. We'll need to attach to each of the
<code>someExpensiveCall.pre</code> and <code>someExpensiveCall.post</code> methods. In the former;
case, if a cache hit is detected, we return it, and move on. In the latter, we
store the value in the cache.</p>
<p>We'll assume <code>$cache</code> is defined, and follows the paradigms of <code>Zend\Cache</code>.
We'll want to return early if a hit is detected, and execute late when saving a
cache (in case the result is modified by another listener). As such, we'll set
the <code>someExpensiveCall.pre</code> listener to execute with priority <code>100</code>, and the
<code>someExpensiveCall.post</code> listener to execute with priority <code>-100</code>.</p>
<pre class="codehilite"><code class="language-php linenums">$events-&gt;attach('someExpensiveCall.pre', function($e) use ($cache) {
    $params = $e-&gt;getParams();
    $key    = md5(json_encode($params));
    $hit    = $cache-&gt;load($key);
    return $hit;
}, 100);

$events-&gt;attach('someExpensiveCall.post', function($e) use ($cache) {
    $params = $e-&gt;getParams();
    $result = $params['__RESULT__'];
    unset($params['__RESULT__']);
    $key    = md5(json_encode($params));
    $cache-&gt;save($result, $key);
}, -100);</code></pre>

<blockquote>
<h3 id="note_3">Note</h3>
<p>The above could have been done within a <code>ListenerAggregate</code>, which would have
allowed keeping the <code>$cache</code> instance as a stateful property, instead of
importing it into closures.</p>
</blockquote>
<p>Another approach would be to move the body of the method to a listener as well,
which would allow using the priority system in order to implement caching. That
would look like this:</p>
<pre class="codehilite"><code class="language-php linenums">public function setEventManager(EventManagerInterface $events)
{
    $this-&gt;events = $events;
    $events-&gt;setIdentifiers(array(__CLASS__, get_class($this)));
    $events-&gt;attach('someExpensiveCall', [$this, 'doSomeExpensiveCall']);
}

public function someExpensiveCall($criteria1, $criteria2)
{
    $params  = compact('criteria1', 'criteria2');
    $results = $this-&gt;getEventManager()-&gt;triggerUntil(
        function ($r) {
            return ($r instanceof SomeResultClass);
        },
        __FUNCTION__,
        $this,
        $params
    );
    return $results-&gt;last();
}

public function doSomeExpensiveCall($e)
{
    // ... do some work ...
    $e-&gt;setParam('__RESULT__', $calculatedResult);
    return $calculatedResult;
}</code></pre>

<p>The listeners would then attach to the <code>someExpensiveCall</code> event, with the cache
lookup listener listening at high priority, and the cache storage listener
listening at low (negative) priority.</p>
<p>Sure, we could probably simply add caching to the object itself — but this
approach allows the same handlers to be attached to multiple events, or to
attach multiple listeners to the same events (e.g. an argument validator, a
logger and a cache manager). The point is that if you design your object with
events in mind, you can easily make it more flexible and extensible, without
requiring developers to actually extend it — they can simply attach listeners.</p>
<h2 id="conclusion">Conclusion</h2>
<p>The <code>EventManager</code> is a powerful component. It drives the workflow of zend-mvc,
and is used in countless components to provide hook points for developers to
manipulate the workflow. It can be put to any number of uses inside your own
code, and is an important part of your Zend Framework toolbox.</p>

<hr />


<nav>
  <ul class="pager hidden-print">
    <li class="previous">
      <a rel="prev" href="../quick-start/"><i class="fa fa-arrow-left"></i> Previous</a>
    </li>
    <li class="next">
      <a rel="next" href="../examples/">Next <i class="fa fa-arrow-right"></i></a>
    </li>
  </ul>
</nav>
</div>
        
    </div>
    <!-- content:end -->

    <footer class="col-md-12 text-center">
        <hr>
        <p>
        <small>Copyright (c) 2016 <a href="http://www.zend.com/">Zend Technologies USA Inc.</a><br></small>
        </p>
        <p><small><a href="http://framework.zend.com">Learn more about Zend Framework</a></small></p>
    </footer>

    <script src="../js/jquery-1.10.2.min.js"></script>
    <script src="../js/bootstrap-3.0.3.min.js"></script>
    <script src="../js/prism-zf.js"></script>

    <script>var base_url = '..';</script>
    <script data-main="../mkdocs/js/search.js" src="../mkdocs/js/require.js"></script>
    <script src="../js/base.js"></script>

    <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <button type="button" class="close" data-dismiss="modal">
                        <span aria-hidden="true">&times;</span>
                        <span class="sr-only">Close</span>
                    </button>
                    <h4 class="modal-title" id="exampleModalLabel">Search</h4>
                </div>
                <div class="modal-body">
                    <p>
                        From here you can search these documents. Enter your search terms below.
                    </p>
                    <form role="form">
                        <div class="form-group">
                            <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query">
                        </div>
                    </form>
                    <div id="mkdocs-search-results"></div>
                </div>
                <div class="modal-footer">
                </div>
            </div>
        </div>
    </div>

    <div class="zf-components">
  <div class="zf-components-grid">
    <div class="zf-logo">
      <a href="http://framework.zend.com" data-toggle="tooltip" data-placement="bottom" title="Go to the ZF homepage"><img src="http://framework.zend.com/images/logos/zf-logo-mark.png" alt="Zend Framework" width="250" /></a>
    </div>

    <div class="component-list"></div>

    <p class="zf-components-rollup"><a href="#">Hide list</a></p>
  </div>
</div>

    <script>
  // Prepare the component list dropdown for display
  $(function () {
    var components = $(".zf-components"),
        componentList = components.find(".component-list"),
        sidebar = $(".bs-sidebar.affix"),
        sidebarInitialPos = sidebar.css("position"),
        hidden,
        componentToggle = $(".component-toggle"),
        navbar = $(".navbar-fixed-top"),
        rollUpLink = $(".zf-components-rollup a");

    // Initial setup on document load
    components.insertBefore(navbar);
    $(".zf-logo a").tooltip();
    componentToggle.tooltip();
    rollUpLink.attr({ href: "#", alt: "Hide component list" });

    // Cast initial sidebar position value
    if (undefined === sidebarInitialPos) {
      sidebarInitialPos = "fixed";
    }

    // Setup onclick events to toggle list
    componentToggle.click(toggleComponentList);
    rollUpLink.click(toggleComponentList);

    // Toggle the component list display
    function toggleComponentList(event) {
      event.preventDefault();

      if (hidden === undefined) {
        // Not loaded yet; load and display.
        loadComponentList();
        return;
      }

      if (hidden) {
        // Hidden; display.
        showComponentList();
        return;
      }

      // Currently visible; hide
      hideComponentList();
    }

    // Show the component list
    function showComponentList() {
      navbar.css({position: "relative"});
      sidebar.css({position: "relative"});
      components
        .css({"margin-top": "-" + components.outerHeight() + "px"})
        .show()
        .animate({"margin-top": 0}, {
          complete: function () {
            componentToggle
              .data("placement", "top")
              .attr("data-original-title", "Hide component list");
            hidden = false;
          },
          queue: false
        });
    }

    // Hide the component list
    function hideComponentList() {
      components.animate({"margin-top": "-" + components.outerHeight() + "px"}, {
        complete: function () {
          navbar.css({position: "fixed"});
          sidebar.css({position: sidebarInitialPos});
          componentToggle
            .data("placement", "bottom")
            .attr("data-original-title", "Show component list");
          components.hide();
          hidden = true;
        },
        queue: false
      });
      sidebar.animate({ top: sidebarInitialTop + "px" }, { queue: false});
    }

    // Inject a component into the componet list DOM.
    function injectComponent(index, component) {
      componentList.append('<div class="component"><h4><a href="' + component.url + '">' + component.name + '</a></h4><p>' + component.description + '</p></div>');
    }

    // Parse the component list, build the DOM, and display it.
    function parseComponentList(components) {
      $.each(components, injectComponent);
      showComponentList();
    }

    // Fetch the component list and display it.
    function loadComponentList () {
      $.ajax({
        url: "//zendframework.github.io/zf-mkdoc-theme/scripts/zf-component-list.json",
        dataType: "text json",
        success: parseComponentList,
        error: function (e) {
          console.log("Error occurred with XHR call", e);
        }
      });
    }
  });
</script>
    </body>

</html>
