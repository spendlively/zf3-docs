<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">  
    <link rel="shortcut icon" href="../img/favicon.ico">

    <title>Standard Filters - zend-filter</title>

    <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css" rel="stylesheet">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/font-hack/2.018/css/hack.min.css">
    <link href="//fonts.googleapis.com/css?family=PT+Sans:400,400italic,700,700italic&subset=latin-ext,latin" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,700italic,400,300,600,700&subset=latin-ext,latin" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Libre+Baskerville:400,400italic,700&subset=latin,latin-ext" rel="stylesheet" type="text/css">
    <link href="../css/base.css" rel="stylesheet">
    <link href="../css/zf-web.css" rel="stylesheet">
    <link href="../css/zf.css" rel="stylesheet">
    <link href="../css/prism-zf.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

    <script src="https://ajax.googleapis.com/ajax/libs/webfont/1.5.18/webfont.js"></script>
    <script>
    WebFont.load({
        google: {
            families: ['Open Sans', 'PT Sans']
        }
    });
    </script>

    
</head>

<body>

    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            

            <!-- Main title -->
            <span class="navbar-brand">
              <a class="logo-link" href="http://framework.zend.com" data-toggle="tooltip" data-placement="bottom" title="Zend Framework"><img src="../img/zf-logo-mark.svg" height="28" alt="Zend Framework" /></a>
              <a href="..">zend-filter</a>
            </span>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                
                
                    <li >
                        <a href="..">Home</a>
                    </li>
                
                
                
                    <li >
                        <a href="../intro/">Intro</a>
                    </li>
                
                
                
                    <li class="dropdown active">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Reference <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li class="active">
    <a href="./">Standard Filters</a>
</li>

                        
                            
<li >
    <a href="../word/">Word Filters</a>
</li>

                        
                            
<li >
    <a href="../file/">File Filters</a>
</li>

                        
                            
<li >
    <a href="../filter-chains/">Filter Chains</a>
</li>

                        
                            
<li >
    <a href="../inflector/">String Inflection</a>
</li>

                        
                            
<li >
    <a href="../static-filter/">Static Filter</a>
</li>

                        
                            
<li >
    <a href="../writing-filters/">Writing Filters</a>
</li>

                        
                        </ul>
                    </li>
                
                
                </ul>
            

            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="#" class="component-toggle" data-toggle="tooltip" data-placement="bottom" title="Show component list">
                        <i class="fa fa-book"></i> Components
                    </a>
                </li>

                <li>
                    <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                        <i class="fa fa-search"></i> Search
                    </a>
                </li>
                
                    <li>
                        <a href="https://github.com/zendframework/zend-filter">
                            
                                <i class="fa fa-github"></i>
                            
                            GitHub
                        </a>
                    </li>
                
            </ul>
        </div>
    </div>
</div>

    <!-- content:begin -->
    <div id="page-top" class="container docs">
        
        <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#standard-filter-classes">Standard Filter Classes</a></li>
        
            <li><a href="#alnum">Alnum</a></li>
        
            <li><a href="#alpha">Alpha</a></li>
        
            <li><a href="#basename">BaseName</a></li>
        
            <li><a href="#blacklist">Blacklist</a></li>
        
            <li><a href="#boolean">Boolean</a></li>
        
            <li><a href="#callback">Callback</a></li>
        
            <li><a href="#compress-and-decompress">Compress and Decompress</a></li>
        
            <li><a href="#digits">Digits</a></li>
        
            <li><a href="#dir">Dir</a></li>
        
            <li><a href="#encrypt-and-decrypt">Encrypt and Decrypt</a></li>
        
            <li><a href="#htmlentities">HtmlEntities</a></li>
        
            <li><a href="#toint">ToInt</a></li>
        
            <li><a href="#tonull">ToNull</a></li>
        
            <li><a href="#numberformat">NumberFormat</a></li>
        
            <li><a href="#numberparse">NumberParse</a></li>
        
            <li><a href="#pregreplace">PregReplace</a></li>
        
            <li><a href="#realpath">RealPath</a></li>
        
            <li><a href="#stringtolower">StringToLower</a></li>
        
            <li><a href="#stringtoupper">StringToUpper</a></li>
        
            <li><a href="#stringtrim">StringTrim</a></li>
        
            <li><a href="#stripnewlines">StripNewlines</a></li>
        
            <li><a href="#striptags">StripTags</a></li>
        
            <li><a href="#urinormalize">UriNormalize</a></li>
        
            <li><a href="#whitelist">Whitelist</a></li>
        
    
    </ul>

    
    <ul class="pager hidden-print">
      <li class="previous">
        <a rel="prev" href="../intro/"><i class="fa fa-arrow-left"></i> Previous</a>
      </li>
      <li class="next">
        <a rel="next" href="../word/">Next <i class="fa fa-arrow-right"></i></a>
      </li>
    </ul>
    
</div></div>
        <div class="col-md-9" role="main">

<ol class="breadcrumb" role="navigation" aria-label="breadcrumbs navigation">
  <li><a href="..">zend-filter</a> &raquo;</li>
  
    
      
        <li>Reference &raquo;</li>
      
    
  
  <li class="active">Standard Filters</li>
</ol>

<h1 id="standard-filter-classes">Standard Filter Classes</h1>
<p>zend-filter comes with a standard set of filters, available for immediate use.</p>
<h2 id="alnum">Alnum</h2>
<p>The <code>Alnum</code> filter can be used to return only alphabetic characters and digits
in the unicode "letter" and "number" categories, respectively. All other
characters are suppressed.</p>
<p>This filter is part of the zend-i18n package; you will need to include that
package in your application to use it.</p>
<h3 id="supported-options">Supported Options</h3>
<p>The following options are supported for <code>Alnum</code>:</p>
<pre class="codehilite"><code class="language-php">Alnum([ boolean $allowWhiteSpace [, string $locale ]])</code></pre>


<ul>
<li>
<p><code>$allowWhiteSpace</code>: If set to true, then whitespace characters are allowed.
  Otherwise they are suppressed. Default is <code>false</code> (whitespace is not allowed).<br />
  Methods for getting/setting the <code>allowWhiteSpace</code> option are also available:
  <code>getAllowWhiteSpace()</code> and <code>setAllowWhiteSpace()</code>.</p>
</li>
<li>
<p><code>$locale</code>: The locale string used in identifying the characters to filter
  (locale name, e.g. <code>en_US</code>). If unset, it will use the default locale
  (<code>Locale::getDefault()</code>). Methods for getting/setting the locale are also
  available: <code>getLocale()</code> and <code>setLocale()</code>.</p>
</li>
</ul>
<h3 id="basic-usage">Basic Usage</h3>
<pre class="codehilite"><code class="language-php">// Default settings, deny whitespace
$filter = new \Zend\I18n\Filter\Alnum();
echo $filter-&gt;filter('This is (my) content: 123');
// Returns 'Thisismycontent123'

// First param in constructor is $allowWhiteSpace
$filter = new \Zend\I18n\Filter\Alnum(true);
echo $filter-&gt;filter('This is (my) content: 123');
// Returns 'This is my content 123'</code></pre>


<blockquote>
<h4 id="supported-languages">Supported languages</h4>
<p><code>Alnum</code> works on almost all languages, except: Chinese, Japanese and Korean.
Within these languages, the english alphabet is used instead of the characters
from these languages. The language itself is detected using the <code>Locale</code>
class.</p>
</blockquote>
<h2 id="alpha">Alpha</h2>
<p>The <code>Alpha</code> filter can be used to return only alphabetic characters in the unicode "letter"
category. All other characters are suppressed.</p>
<p>This filter is part of the zend-i18n package; you will need to include that
package in your application to use it.</p>
<h3 id="supported-options_1">Supported Options</h3>
<p>The following options are supported for <code>Alpha</code>:</p>
<pre class="codehilite"><code class="language-php">Alpha([ boolean $allowWhiteSpace [, string $locale ]])</code></pre>


<ul>
<li>
<p><code>$allowWhiteSpace</code>: If set to true then whitespace characters are allowed.
  Otherwise they are suppressed. Default is <code>false</code> (whitespace is not allowed).
  Methods for getting/setting the allowWhiteSpace option are also available:
  <code>getAllowWhiteSpace()</code> and <code>setAllowWhiteSpace()</code>.</p>
</li>
<li>
<p><code>$locale</code>: The locale string used in identifying the characters to filter
  (locale name, e.g. <code>en_US</code>). If unset, it will use the default locale
  (<code>Locale::getDefault()</code>).  Methods for getting/setting the locale are also
  available: <code>getLocale()</code> and <code>setLocale()</code>.</p>
</li>
</ul>
<h3 id="basic-usage_1">Basic Usage</h3>
<pre class="codehilite"><code class="language-php">// Default settings, deny whitespace
$filter = new \Zend\I18n\Filter\Alpha();
echo $filter-&gt;filter('This is (my) content: 123');
// Returns 'Thisismycontent'

// Allow whitespace
$filter = new \Zend\I18n\Filter\Alpha(true);
echo $filter-&gt;filter('This is (my) content: 123');
// Returns 'This is my content '</code></pre>


<blockquote>
<h4 id="supported-languages_1">Supported languages</h4>
<p><code>Alpha</code> works on almost all languages, except: Chinese, Japanese and Korean.
Within these languages, the english alphabet is used instead of the characters
from these languages. The language itself is detected using the <code>Locale</code>
class.</p>
</blockquote>
<h2 id="basename">BaseName</h2>
<p><code>Zend\Filter\BaseName</code> allows you to filter a string which contains the path to
a file, and it will return the base name of this file.</p>
<h3 id="supported-options_2">Supported Options</h3>
<p>There are no additional options for <code>Zend\Filter\BaseName</code>.</p>
<h3 id="basic-usage_2">Basic Usage</h3>
<pre class="codehilite"><code class="language-php">$filter = new Zend\Filter\BaseName();

print $filter-&gt;filter('/vol/tmp/filename');</code></pre>


<p>This will return 'filename'.</p>
<pre class="codehilite"><code class="language-php">$filter = new Zend\Filter\BaseName();

print $filter-&gt;filter('/vol/tmp/filename.txt');</code></pre>


<p>This will return '<code>filename.txt</code>'.</p>
<h2 id="blacklist">Blacklist</h2>
<p>This filter will return <code>null</code> if the value being filtered is present in the filter's list of
values. If the value is not present, it will return that value.</p>
<p>For the opposite functionality, see the <a href="#whitelist"><code>Whitelist</code> filter</a>.</p>
<h3 id="supported-options_3">Supported Options</h3>
<p>The following options are supported for <code>Zend\Filter\Blacklist</code>:</p>
<ul>
<li><code>strict</code>: Uses strict mode when comparing; passed to <code>in_array()</code>'s third argument.</li>
<li><code>list</code>: An array of forbidden values.</li>
</ul>
<h3 id="basic-usage_3">Basic Usage</h3>
<pre class="codehilite"><code class="language-php">$blacklist = new \Zend\Filter\Blacklist([
    'list' =&gt; ['forbidden-1', 'forbidden-2']
]);
echo $blacklist-&gt;filter('forbidden-1'); // =&gt; null
echo $blacklist-&gt;filter('allowed');     // =&gt; 'allowed'</code></pre>


<h2 id="boolean">Boolean</h2>
<p>This filter changes a given input to be a <code>BOOLEAN</code> value. This is often useful when working with
databases or when processing form values.</p>
<h3 id="supported-options_4">Supported Options</h3>
<p>The following options are supported for <code>Zend\Filter\Boolean</code>:</p>
<ul>
<li><code>casting</code>: When this option is set to <code>TRUE</code>, then any given input will be
  cast to boolean.  This option defaults to <code>TRUE</code>.</li>
<li><code>translations</code>: This option sets the translations which will be used to detect localized input.</li>
<li><code>type</code>: The <code>type</code> option sets the boolean type which should be used. Read
  the following for details.</li>
</ul>
<h3 id="default-behavior">Default Behavior</h3>
<p>By default, this filter works by casting the input to a <code>BOOLEAN</code> value; in other words, it operates
in a similar fashion to calling <code>(boolean) $value</code>.</p>
<pre class="codehilite"><code class="language-php">$filter = new Zend\Filter\Boolean();
$value  = '';
$result = $filter-&gt;filter($value);
// returns false</code></pre>


<p>This means that without providing any configuration, <code>Zend\Filter\Boolean</code> accepts all input types
and returns a <code>BOOLEAN</code> just as you would get by type casting to <code>BOOLEAN</code>.</p>
<h3 id="changing-the-default-behavior">Changing the Default Behavior</h3>
<p>Sometimes, casting with <code>(boolean)</code> will not suffice. <code>Zend\Filter\Boolean</code>
allows you to configure specific types to convert, as well as which to omit.</p>
<p>The following types can be handled:</p>
<ul>
<li><code>boolean</code>: Returns a boolean value as is.</li>
<li><code>integer</code>: Converts an integer <code>0</code> value to <code>FALSE</code>.</li>
<li><code>float</code>: Converts a float <code>0.0</code> value to <code>FALSE</code>.</li>
<li><code>string</code>: Converts an empty string <code>''</code> to <code>FALSE</code>.</li>
<li><code>zero</code>: Converts a string containing the single character zero (<code>'0'</code>) to <code>FALSE</code>.</li>
<li><code>empty_array</code>: Converts an empty <code>array</code> to <code>FALSE</code>.</li>
<li><code>null</code>: Converts a <code>NULL</code> value to <code>FALSE</code>.</li>
<li><code>php</code>: Converts values according to PHP when casting them to <code>BOOLEAN</code>.</li>
<li><code>false_string</code>: Converts a string containing the word "false" to a boolean <code>FALSE</code>.</li>
<li><code>yes</code>: Converts a localized string which contains the word "no" to <code>FALSE</code>.</li>
<li><code>all</code>: Converts all above types to <code>BOOLEAN</code>.</li>
</ul>
<p>All other given values will return <code>TRUE</code> by default.</p>
<p>There are several ways to select which of the above types are filtered. You can
give one or multiple types and add them, you can give an array, you can use
constants, or you can give a textual string.  See the following examples:</p>
<pre class="codehilite"><code class="language-php">// converts 0 to false
$filter = new Zend\Filter\Boolean(Zend\Filter\Boolean::TYPE_INTEGER);

// converts 0 and '0' to false
$filter = new Zend\Filter\Boolean(
    Zend\Filter\Boolean::TYPE_INTEGER + Zend\Filter\Boolean::TYPE_ZERO_STRING
);

// converts 0 and '0' to false
$filter = new Zend\Filter\Boolean([
    'type' =&gt; [
        Zend\Filter\Boolean::TYPE_INTEGER,
        Zend\Filter\Boolean::TYPE_ZERO_STRING,
    ],
]);

// converts 0 and '0' to false
$filter = new Zend\Filter\Boolean([
    'type' =&gt; [
        'integer',
        'zero',
    ],
]);</code></pre>


<p>You can also give an instance of <code>Zend\Config\Config</code> to set the desired types.
To set types after instantiation, use the <code>setType()</code> method.</p>
<h3 id="localized-booleans">Localized Booleans</h3>
<p>As mentioned previously, <code>Zend\Filter\Boolean</code> can also recognise localized "yes" and "no" strings.
This means that you can ask your customer in a form for "yes" or "no" within his native language and
<code>Zend\Filter\Boolean</code> will convert the response to the appropriate boolean value.</p>
<p>To set the translation and the corresponding value, you can use the <code>translations</code> option or the
method <code>setTranslations</code>.</p>
<pre class="codehilite"><code class="language-php">$filter = new Zend\Filter\Boolean([
    'type'         =&gt; Zend\Filter\Boolean::TYPE_LOCALIZED,
    'translations' =&gt; [
        'ja'   =&gt; true,
        'nein' =&gt; false,
        'yes'  =&gt; true,
        'no'   =&gt; false,
    ],
]);

// returns false
$result = $filter-&gt;filter('nein');

// returns true
$result = $filter-&gt;filter('yes');</code></pre>


<h3 id="disable-casting">Disable Casting</h3>
<p>Sometimes it is necessary to recognise only <code>TRUE</code> or <code>FALSE</code> and return all
other values without changes. <code>Zend\Filter\Boolean</code> allows you to do this by
setting the <code>casting</code> option to <code>FALSE</code>.</p>
<p>In this case <code>Zend\Filter\Boolean</code> will work as described in the following
table, which shows which values return <code>TRUE</code> or <code>FALSE</code>. All other given values
are returned without change when <code>casting</code> is set to <code>FALSE</code></p>
<div class="table-responsive"><table>
<thead>
<tr>
<th>Type</th>
<th>True</th>
<th>False</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Zend\Filter\Boolean::TYPE_BOOLEAN</code></td>
<td><code>TRUE</code></td>
<td><code>FALSE</code></td>
</tr>
<tr>
<td><code>Zend\Filter\Boolean::TYPE_EMPTY_ARRAY</code></td>
<td><code>array()</code></td>
<td></td>
</tr>
<tr>
<td><code>Zend\Filter\Boolean::TYPE_FALSE_STRING</code></td>
<td><code>"false"</code> (case insensitive)</td>
<td><code>"true"</code> (case insensitive)</td>
</tr>
<tr>
<td><code>Zend\Filter\Boolean::TYPE_FLOAT</code></td>
<td><code>0.0</code></td>
<td><code>1.0</code></td>
</tr>
<tr>
<td><code>Zend\Filter\Boolean::TYPE_INTEGER</code></td>
<td><code>0</code></td>
<td><code>1</code></td>
</tr>
<tr>
<td><code>Zend\Filter\Boolean::TYPE_LOCALIZED</code></td>
<td>localized <code>"yes"</code> (case insensitive)</td>
<td>localized <code>"no"</code> (case insensitive)</td>
</tr>
<tr>
<td><code>Zend\Filter\Boolean::TYPE_NULL</code></td>
<td><code>NULL</code></td>
<td></td>
</tr>
<tr>
<td><code>Zend\Filter\Boolean::TYPE_STRING</code></td>
<td><code>""</code></td>
<td></td>
</tr>
<tr>
<td><code>Zend\Filter\Boolean::TYPE_ZERO_STRING</code></td>
<td><code>"0"</code></td>
<td><code>"1"</code></td>
</tr>
</tbody>
</table></div>
<p>The following example shows the behaviour when changing the <code>casting</code> option:</p>
<pre class="codehilite"><code class="language-php">$filter = new Zend\Filter\Boolean([
    'type'    =&gt; Zend\Filter\Boolean::TYPE_ALL,
    'casting' =&gt; false,
]);

// returns false
$result = $filter-&gt;filter(0);

// returns true
$result = $filter-&gt;filter(1);

// returns the value
$result = $filter-&gt;filter(2);</code></pre>


<h2 id="callback">Callback</h2>
<p>This filter allows you to use own methods in conjunction with <code>Zend\Filter</code>. You
don't have to create a new filter when you already have a method which does the
job.</p>
<h3 id="supported-options_5">Supported Options</h3>
<p>The following options are supported for <code>Zend\Filter\Callback</code>:</p>
<ul>
<li><code>callback</code>: This sets the callback which should be used.</li>
<li><code>callback_params</code>: This property sets the options which are used when the
  callback is processed.</li>
</ul>
<h3 id="basic-usage_4">Basic Usage</h3>
<p>The usage of this filter is quite simple. In this example, we want to create a
filter which reverses a string:</p>
<pre class="codehilite"><code class="language-php">$filter = new Zend\Filter\Callback('strrev');

print $filter-&gt;filter('Hello!');
// returns &quot;!olleH&quot;</code></pre>


<p>As you can see it's really simple to use a callback to define custom filters. It
is also possible to use a method, which is defined within a class, by giving an
array as the callback:</p>
<pre class="codehilite"><code class="language-php">class MyClass
{
    public static function reverse($param);
}

// The filter definition
$filter = new Zend\Filter\Callback(array('MyClass', 'reverse'));
print $filter-&gt;filter('Hello!');</code></pre>


<p>To get the actual set callback use <code>getCallback()</code> and to set another callback
use <code>setCallback()</code>.</p>
<blockquote>
<h4 id="possible-exceptions">Possible exceptions</h4>
<p>You should note that defining a callback method which can not be called will
raise an exception.</p>
</blockquote>
<h3 id="default-parameters-within-a-callback">Default Parameters Within a Callback</h3>
<p>It is also possible to define default parameters, which are given to the called
method as an array when the filter is executed. This array will be concatenated
with the value which will be filtered.</p>
<pre class="codehilite"><code class="language-php">$filter = new Zend\Filter\Callback([
    'callback' =&gt; 'MyMethod',
    'options'  =&gt; ['key' =&gt; 'param1', 'key2' =&gt; 'param2']
]);
$filter-&gt;filter(['value' =&gt; 'Hello']);</code></pre>


<p>Calling the above method definition manually would look like this:</p>
<pre class="codehilite"><code class="language-php">$value = MyMethod('Hello', 'param1', 'param2');</code></pre>


<h2 id="compress-and-decompress">Compress and Decompress</h2>
<p>These two filters are capable of compressing and decompressing strings, files, and directories.</p>
<h3 id="supported-options_6">Supported Options</h3>
<p>The following options are supported for <code>Zend\Filter\Compress</code> and <code>Zend\Filter\Decompress</code>:</p>
<ul>
<li><code>adapter</code>: The compression adapter which should be used. It defaults to <code>Gz</code>.</li>
<li><code>options</code>: Additional options which are given to the adapter at initiation.
  Each adapter supports its own options.</li>
</ul>
<h3 id="supported-compression-adapters">Supported Compression Adapters</h3>
<p>The following compression formats are supported by their own adapter:</p>
<ul>
<li><strong>Bz2</strong></li>
<li><strong>Gz</strong></li>
<li><strong>Lzf</strong></li>
<li><strong>Rar</strong></li>
<li><strong>Tar</strong></li>
<li><strong>Zip</strong></li>
</ul>
<p>Each compression format has different capabilities as described below. All
compression filters may be used in approximately the same ways, and differ
primarily in the options available and the type of compression they offer (both
algorithmically as well as string vs. file vs. directory)</p>
<h3 id="generic-handling">Generic Handling</h3>
<p>To create a compression filter, you need to select the compression format you want to use. The
following example takes the <strong>Bz2</strong> adapter. Details for all other adapters are described after
this section.</p>
<p>The two filters are basically identical, in that they utilize the same backends.
<code>Zend\Filter\Compress</code> should be used when you wish to compress items, and <code>Zend\Filter\Decompress</code>
should be used when you wish to decompress items.</p>
<p>For instance, if we want to compress a string, we have to initialize <code>Zend\Filter\Compress</code> and
indicate the desired adapter:</p>
<pre class="codehilite"><code class="language-php">$filter = new Zend\Filter\Compress('Bz2');</code></pre>


<p>To use a different adapter, you simply specify it to the constructor.</p>
<p>You may also provide an array of options or a <code>Traversable</code> object. If you do,
provide minimally the key "adapter", and then either the key "options" or
"adapterOptions", both of which should be an array of options to provide to the
adapter on instantiation.</p>
<pre class="codehilite"><code class="language-php">$filter = new Zend\Filter\Compress([
    'adapter' =&gt; 'Bz2',
    'options' =&gt; [
        'blocksize' =&gt; 8,
    ],
]);</code></pre>


<blockquote>
<h4 id="default-compression-adapter">Default compression Adapter</h4>
<p>When no compression adapter is given, then the <strong>Gz</strong> adapter will be used.</p>
</blockquote>
<p>Decompression is essentially the same usage; we simply use the <code>Decompress</code>
filter instead:</p>
<pre class="codehilite"><code class="language-php">$filter = new Zend\Filter\Decompress('Bz2');</code></pre>


<p>To get the compressed string, we have to give the original string. The filtered value is the
compressed version of the original string.</p>
<pre class="codehilite"><code class="language-php">$filter     = new Zend\Filter\Compress('Bz2');
$compressed = $filter-&gt;filter('Uncompressed string');
// Returns the compressed string</code></pre>


<p>Decompression works in reverse, accepting the compressed string, and returning
the original:</p>
<pre class="codehilite"><code class="language-php">$filter     = new Zend\Filter\Decompress('Bz2');
$compressed = $filter-&gt;filter('Compressed string');
// Returns the original, uncompressed string</code></pre>


<blockquote>
<h4 id="note-on-string-compression">Note on string compression</h4>
<p>Not all adapters support string compression. Compression formats like <strong>Rar</strong>
can only handle files and directories. For details, consult the section for
the adapter you wish to use.</p>
</blockquote>
<h3 id="creating-an-archive">Creating an Archive</h3>
<p>Creating an archive file works almost the same as compressing a string. However, in this case we
need an additional parameter which holds the name of the archive we want to create.</p>
<pre class="codehilite"><code class="language-php">$filter = new Zend\Filter\Compress([
    'adapter' =&gt; 'Bz2',
    'options' =&gt; [
        'archive' =&gt; 'filename.bz2',
    ],
]);
$compressed = $filter-&gt;filter('Uncompressed string');
// Returns true on success, and creates the archive file</code></pre>


<p>In the above example, the uncompressed string is compressed, and is then written
into the given archive file.</p>
<blockquote>
<h4 id="existing-archives-will-be-overwritten">Existing archives will be overwritten</h4>
<p>The content of any existing file will be overwritten when the given filename
of the archive already exists.</p>
</blockquote>
<p>When you want to compress a file, then you must give the name of the file with its path:</p>
<pre class="codehilite"><code class="language-php">$filter = new Zend\Filter\Compress([
    'adapter' =&gt; 'Bz2',
    'options' =&gt; [
        'archive' =&gt; 'filename.bz2'
    ],
]);
$compressed = $filter-&gt;filter('C:\temp\compressme.txt');
// Returns true on success and creates the archive file</code></pre>


<p>You may also specify a directory instead of a filename. In this case the whole
directory with all its files and subdirectories will be compressed into the
archive:</p>
<pre class="codehilite"><code class="language-php">$filter = new Zend\Filter\Compress([
    'adapter' =&gt; 'Bz2',
    'options' =&gt; [
        'archive' =&gt; 'filename.bz2'
    ],
]);
$compressed = $filter-&gt;filter('C:\temp\somedir');
// Returns true on success and creates the archive file</code></pre>


<blockquote>
<h4 id="do-not-compress-large-or-base-directories">Do not compress large or base directories</h4>
<p>You should never compress large or base directories like a complete partition.
Compressing a complete partition is a very time consuming task which can lead
to massive problems on your server when there is not enough space or your
script takes too much time.</p>
</blockquote>
<h3 id="decompressing-an-archive">Decompressing an Archive</h3>
<p>Decompressing an archive file works almost like compressing it. You must specify either the
<code>archive</code> parameter, or give the filename of the archive when you decompress the file.</p>
<pre class="codehilite"><code class="language-php">$filter = new Zend\Filter\Decompress('Bz2');
$decompressed = $filter-&gt;filter('filename.bz2');
// Returns true on success and decompresses the archive file</code></pre>


<p>Some adapters support decompressing the archive into another subdirectory. In
this case you can set the <code>target</code> parameter:</p>
<pre class="codehilite"><code class="language-php">$filter = new Zend\Filter\Decompress([
    'adapter' =&gt; 'Zip',
    'options' =&gt; [
        'target' =&gt; 'C:\temp',
    ]
]);
$decompressed = $filter-&gt;filter('filename.zip');
// Returns true on success, and decompresses the archive file
// into the given target directory</code></pre>


<blockquote>
<h4 id="directories-to-extract-to-must-exist">Directories to extract to must exist</h4>
<p>When you want to decompress an archive into a directory, then the target
directory must exist.</p>
</blockquote>
<h3 id="bz2-adapter">Bz2 Adapter</h3>
<p>The Bz2 Adapter can compress and decompress:</p>
<ul>
<li>Strings</li>
<li>Files</li>
<li>Directories</li>
</ul>
<p>This adapter makes use of PHP's Bz2 extension.</p>
<p>To customize compression, this adapter supports the following options:</p>
<ul>
<li><code>archive</code>: This parameter sets the archive file which should be used or created.</li>
<li><code>blocksize</code>: This parameter sets the blocksize to use. It can be from '0' to
  '9'. The default value is '4'.</li>
</ul>
<p>All options can be set at instantiation or by using a related method; for example, the related
methods for 'blocksize' are <code>getBlocksize()</code> and <code>setBlocksize()</code>. You can also use the
<code>setOptions()</code> method, which accepts an array of all options.</p>
<h3 id="gz-adapter">Gz Adapter</h3>
<p>The Gz Adapter can compress and decompress:</p>
<ul>
<li>Strings</li>
<li>Files</li>
<li>Directories</li>
</ul>
<p>This adapter makes use of PHP's Zlib extension.</p>
<p>To customize the compression this adapter supports the following options:</p>
<ul>
<li><code>archive</code>: This parameter sets the archive file which should be used or created.</li>
<li><code>level</code>: This compression level to use. It can be from '0' to '9'. The default
  value is '9'.</li>
<li><code>mode</code>: There are two supported modes. <code>compress</code> and <code>deflate</code>. The default
  value is <code>compress</code>.</li>
</ul>
<p>All options can be set at initiation or by using a related method. For example, the related methods
for <code>level</code> are <code>getLevel()</code> and <code>setLevel()</code>. You can also use the <code>setOptions()</code> method which
accepts an array of all options.</p>
<h3 id="lzf-adapter">Lzf Adapter</h3>
<p>The Lzf Adapter can compress and decompress:</p>
<ul>
<li>Strings</li>
</ul>
<blockquote>
<h4 id="lzf-supports-only-strings">Lzf supports only strings</h4>
<p>The Lzf adapter can not handle files and directories.</p>
</blockquote>
<p>This adapter makes use of PHP's Lzf extension.</p>
<p>There are no options available to customize this adapter.</p>
<h3 id="rar-adapter">Rar Adapter</h3>
<p>The Rar Adapter can compress and decompress:</p>
<ul>
<li>Files</li>
<li>Directories</li>
</ul>
<blockquote>
<h4 id="rar-does-not-support-strings">Rar does not support strings</h4>
<p>The Rar Adapter can not handle strings.</p>
</blockquote>
<p>This adapter makes use of PHP's Rar extension.</p>
<blockquote>
<h4 id="rar-compression-not-supported">Rar compression not supported</h4>
<p>Due to restrictions with the Rar compression format, there is no compression
available for free. When you want to compress files into a new Rar archive,
you must provide a callback to the adapter that can invoke a Rar compression
program.</p>
</blockquote>
<p>To customize compression, this adapter supports the following options:</p>
<ul>
<li><code>archive</code>: This parameter sets the archive file which should be used or created.</li>
<li><code>callback</code>: A callback which provides compression support to this adapter.</li>
<li><code>password</code>: The password which has to be used for decompression.</li>
<li><code>target</code>: The target where the decompressed files will be written to.</li>
</ul>
<p>All options can be set at instantiation or by using a related method. For example, the related
methods for <code>target</code> are <code>getTarget()</code> and <code>setTarget()</code>. You can also use the <code>setOptions()</code> method
which accepts an array of all options.</p>
<h3 id="tar-adapter">Tar Adapter</h3>
<p>The Tar Adapter can compress and decompress:</p>
<ul>
<li>Files</li>
<li>Directories</li>
</ul>
<blockquote>
<h4 id="tar-does-not-support-strings">Tar does not support strings</h4>
<p>The Tar Adapter can not handle strings.</p>
</blockquote>
<p>This adapter makes use of PEAR's <code>Archive_Tar</code> component.</p>
<p>To customize compression, this adapter supports the following options:</p>
<ul>
<li><code>archive</code>: This parameter sets the archive file which should be used or created.</li>
<li><code>mode</code>: A mode to use for compression. Supported are either <code>NULL</code>, which
  means no compression at all; <code>Gz</code>, which makes use of PHP's Zlib extension;
  and <code>Bz2</code>, which makes use of PHP's Bz2 extension. The default value is <code>NULL</code>.</li>
<li><code>target</code>: The target where the decompressed files will be written to.</li>
</ul>
<p>All options can be set at instantiation or by using a related method. For
example, the related methods for <code>target</code> are <code>getTarget()</code> and <code>setTarget()</code>.
You can also use the <code>setOptions()</code> method which accepts an array of all
options.</p>
<blockquote>
<h4 id="directory-usage">Directory usage</h4>
<p>When compressing directories with Tar, the complete file path is used. This
means that created Tar files will not only have the subdirectory, but the
complete path for the compressed file.</p>
</blockquote>
<h3 id="zip-adapter">Zip Adapter</h3>
<p>The Zip Adapter can compress and decompress:</p>
<ul>
<li>Strings</li>
<li>Files</li>
<li>Directories</li>
</ul>
<blockquote>
<h4 id="zip-does-not-support-string-decompression">Zip does not support string decompression</h4>
<p>The Zip Adapter can not handle decompression to a string; decompression will
always be written to a file.</p>
</blockquote>
<p>This adapter makes use of PHP's <code>Zip</code> extension.</p>
<p>To customize compression, this adapter supports the following options:</p>
<ul>
<li><code>archive</code>: This parameter sets the archive file which should be used or created.</li>
<li><code>target</code>: The target where the decompressed files will be written to.</li>
</ul>
<p>All options can be set at instantiation or by using a related method. For example, the related
methods for <code>target</code> are <code>getTarget()</code> and <code>setTarget()</code>. You can also use the <code>setOptions()</code> method
which accepts an array of all options.</p>
<h2 id="digits">Digits</h2>
<p>Returns the string <code>$value</code>, removing all but digits.</p>
<h3 id="supported-options_7">Supported Options</h3>
<p>There are no additional options for <code>Zend\Filter\Digits</code>.</p>
<h3 id="basic-usage_5">Basic Usage</h3>
<pre class="codehilite"><code class="language-php">$filter = new Zend\Filter\Digits();

print $filter-&gt;filter('October 2012');</code></pre>


<p>This returns "2012".</p>
<pre class="codehilite"><code class="language-php">$filter = new Zend\Filter\Digits();

print $filter-&gt;filter('HTML 5 for Dummies');</code></pre>


<p>This returns "5".</p>
<h2 id="dir">Dir</h2>
<p>Given a string containing a path to a file, this function will return the name of the directory.</p>
<h3 id="supported-options_8">Supported Options</h3>
<p>There are no additional options for <code>Zend\Filter\Dir</code>.</p>
<h3 id="basic-usage_6">Basic Usage</h3>
<pre class="codehilite"><code class="language-php">$filter = new Zend\Filter\Dir();

print $filter-&gt;filter('/etc/passwd');</code></pre>


<p>This returns <code>/etc</code>.</p>
<pre class="codehilite"><code class="language-php">$filter = new Zend\Filter\Dir();

print $filter-&gt;filter('C:/Temp/x');</code></pre>


<p>This returns <code>C:/Temp</code>.</p>
<h2 id="encrypt-and-decrypt">Encrypt and Decrypt</h2>
<p>These filters allow encrypting and decrypting any given string; they do so via
the use of adapters. Included adapters support <code>Zend\Crypt\BlockCipher</code> and
PHP's OpenSSL extension.</p>
<h3 id="supported-options_9">Supported Options</h3>
<p>The following options are supported for <code>Zend\Filter\Encrypt</code> and
<code>Zend\Filter\Decrypt</code>, and segregated by adapter.</p>
<h4 id="general-options">General options</h4>
<ul>
<li><code>adapter</code>: This sets the encryption adapter to use.</li>
<li><code>compression</code>: If the encrypted value should be compressed. Default is no
  compression.</li>
</ul>
<h4 id="blockcipher-options">BlockCipher options</h4>
<ul>
<li><code>algorithm</code>: The algorithm to use with <code>Zend\Crypt\Symmetric\Mcrypt</code> (use the
  the <code>getSupportedAlgorithms()</code> method of that class to determine what is
  supported). If not set, it defaults to <code>aes</code>, the Advanced Encryption Standard
  (see the <a href="http://zendframework.github.io/zend-crypt/block-cipher/">zend-crypt BlockCipher documentation</a>
  for details).</li>
<li><code>key</code>: The encryption key with which the input will be encrypted. You need the
  same key for decryption.</li>
<li><code>mode</code>: The encryption mode to use. It should be a
  <a href="http://php.net/manual/en/mcrypt.constants.php">valid PHP mcrypt modes</a>.
  If not set, it defaults to 'cbc'.</li>
<li><code>mode_directory</code>: The directory where the mode can be found. If not set, it
  defaults to the path set within the <code>Mcrypt</code> extension.</li>
<li><code>vector</code>: The initialization vector which shall be used. If not set, it will
  be a random vector.</li>
</ul>
<h4 id="openssl-options">OpenSSL options</h4>
<ul>
<li><code>envelope</code>: The encrypted envelope key from the user who encrypted the
  content. You can either provide the path and filename of the key file, or just
  the content of the key file itself. When the <code>package</code> option has been set,
  then you can omit this parameter.</li>
<li><code>package</code>: If the envelope key should be packed with the encrypted value.
  Default is <code>FALSE</code>.</li>
<li><code>private</code>: The private key to use for encrypting the content. You can either
  provide the path and filename of the key file, or just the content of the key
  file itself.</li>
<li><code>public</code>: The public key of the user for whom you want to provide the
  encrypted content. You can either provide the path and filename of the key
  file, or just the content of the key file itself.</li>
</ul>
<h3 id="adapter-usage">Adapter Usage</h3>
<p>As these two encryption methodologies work completely different, the usage
of the adapters differ. You have to select the adapter you want to use when
initiating the filter.</p>
<pre class="codehilite"><code class="language-php">// Use the BlockCipher adapter
$filter1 = new Zend\Filter\Encrypt(['adapter' =&gt; 'BlockCipher']);

// Use the OpenSSL adapter
$filter2 = new Zend\Filter\Encrypt(['adapter' =&gt; 'openssl']);</code></pre>


<p>To set another adapter, you can use <code>setAdapter()</code>; <code>getAdapter()</code> will return
the currently composed adapter.</p>
<pre class="codehilite"><code class="language-php">// Use the OpenSSL adapter
$filter = new Zend\Filter\Encrypt();
$filter-&gt;setAdapter('openssl');</code></pre>


<blockquote>
<h4 id="default-adapter">Default adapter</h4>
<p>When you do not supply the <code>adapter</code> option or do not call <code>setAdapter()</code>, the
<code>BlockCipher</code> adapter will be used per default.</p>
</blockquote>
<h3 id="encryption-with-blockcipher">Encryption with BlockCipher</h3>
<p>To encrypt a string using the <code>BlockCipher</code> adapter, you have to specify the
encryption key by either calling the <code>setKey()</code> method or passing it to the
constructor.</p>
<pre class="codehilite"><code class="language-php">// Use the default AES encryption algorithm
$filter = new Zend\Filter\Encrypt(['adapter' =&gt; 'BlockCipher']);
$filter-&gt;setKey('encryption key');

// or
// $filter = new Zend\Filter\Encrypt([
//     'adapter' =&gt; 'BlockCipher',
//     'key'     =&gt; 'encryption key'
// ]);

$encrypted = $filter-&gt;filter('text to be encrypted');
printf (&quot;Encrypted text: %s\n&quot;, $encrypted);</code></pre>


<p>You can get and set the encryption values after construction using the
<code>getEncryption()</code> and <code>setEncryption()</code> methods:</p>
<pre class="codehilite"><code class="language-php">// Use the default AES encryption algorithm
$filter = new Zend\Filter\Encrypt(['adapter' =&gt; 'BlockCipher']);
$filter-&gt;setKey('encryption key');
var_dump($filter-&gt;getEncryption());

// Will print:
//array(4) {
//  [&quot;key_iteration&quot;]=&gt;
//  int(5000)
//  [&quot;algorithm&quot;]=&gt;
//  string(3) &quot;aes&quot;
//  [&quot;hash&quot;]=&gt;
//  string(6) &quot;sha256&quot;
//  [&quot;key&quot;]=&gt;
//  string(14) &quot;encryption key&quot;
//}</code></pre>


<blockquote>
<h4 id="default-blockcipher-algorithm">Default BlockCipher algorithm</h4>
<p>The <code>BlockCipher</code> adapter uses the <a href="http://php.net/mcrypt">Mcrypt</a> extension
by default. That means you will need to install the Mcrypt module in your PHP
environment.</p>
</blockquote>
<p>If you don't specify an initialization Vector (salt or iv), the <code>BlockCipher</code> will
generate a random value during each encryption. If you try to execute the
following code, the output will always be different (note that even if the output
is always different, you can still decrypt it using the same key).</p>
<pre class="codehilite"><code class="language-php">$key  = 'encryption key';
$text = 'message to encrypt';

// use the default adapter that is BlockCipher
$filter = new \Zend\Filter\Encrypt();
$filter-&gt;setKey('encryption key');
for ($i = 0; $i &lt; 10; $i++) {
   printf(&quot;%d) %s\n&quot;, $i, $filter-&gt;filter($text));
}</code></pre>


<p>If you want to obtain the same output, you need to specify a fixed vector, using
the <code>setVector()</code> method. This following example always produces the same
encryption output:</p>
<pre class="codehilite"><code class="language-php">// use the default adapter that is BlockCipher
$filter = new \Zend\Filter\Encrypt();
$filter-&gt;setKey('encryption key');
$filter-&gt;setVector('12345678901234567890');
printf(&quot;%s\n&quot;, $filter-&gt;filter('message'));

// output:
//
04636a6cb8276fad0787a2e187803b6557f77825d5ca6ed4392be702b9754bb3MTIzNDU2Nzg5MDEyMzQ1NgZ+zPwTGpV6gQqPKECinig=</code></pre>


<blockquote>
<h4 id="use-diffrent-vectors">Use diffrent vectors</h4>
<p>For security purposes, it's always better to use a different vector on each
encryption. We suggest using <code>setVector()</code> only in exceptional circumstances.</p>
</blockquote>
<h3 id="decryption-with-blockcipher">Decryption with BlockCipher</h3>
<p>For decrypting content previously encrypted with <code>BlockCipher</code>, you need to use
the same options used for encryption.</p>
<p>If you used only the encryption key, you can just use it to decrypt the content.
As soon as you have provided all options, decryption works the same as
encryption.</p>
<pre class="codehilite"><code class="language-php">$content = '04636a6cb8276fad0787a2e187803b6557f77825d5ca6ed4392be702b9754bb3MTIzNDU2Nzg5MDEyMzQ1NgZ+zPwTGpV6gQqPKECinig=';
// use the default adapter (BlockCipher):
$filter = new Zend\Filter\Decrypt();
$filter-&gt;setKey('encryption key');
printf(&quot;Decrypt: %s\n&quot;, $filter-&gt;filter($content));

// output:
// Decrypt: message</code></pre>


<p>Note that even if we did not specify the same vector, the <code>BlockCipher</code> is able
to decrypt the message because the vector is stored in the encryption string
itself (note that the vector can be stored in plaintext; it is not a secret, and
only used to improve the randomness of the encryption algorithm).</p>
<h3 id="encryption-with-openssl">Encryption with OpenSSL</h3>
<p>If you have installed the <code>OpenSSL</code> extension, you can also use the <code>OpenSSL</code>
adapter. You can get or set the public key either during instantiation, or later
via the <code>setPublicKey()</code> method. The private key can also be set after-the-fact
via the <code>setPrivateKey()</code> method.</p>
<pre class="codehilite"><code class="language-php">// Use openssl and provide a private key
$filter = new Zend\Filter\Encrypt([
   'adapter' =&gt; 'openssl',
   'private' =&gt; '/path/to/mykey/private.pem',
]);

// Add the private key separately:
$filter-&gt;setPublicKey('/public/key/path/public.pem');</code></pre>


<blockquote>
<h4 id="valid-keys-are-required">Valid keys are required</h4>
<p>The <code>OpenSSL</code> adapter will not work with invalid or missing keys.</p>
</blockquote>
<p>When you want to decode content encoded with a passphrase, you will not only
need the public key, but also the passphrase:</p>
<pre class="codehilite"><code class="language-php">// Use openssl and provide a private key
$filter = new Zend\Filter\Encrypt([
   'adapter' =&gt; 'openssl',
   'passphrase' =&gt; 'enter here the passphrase for the private key',
   'private' =&gt; '/path/to/mykey/private.pem',
   'public' =&gt; '/public/key/path/public.pem'
]);</code></pre>


<p>When providing the encrypted content to the recipient, you will also need to
ensure they have the passphrase and the envelope keys so they may decrypt the
message. You can get the envelope keys using the <code>getEnvelopeKey()</code> method:</p>
<p>A complete example for encrypting content with <code>OpenSSL</code> looks like the
following:</p>
<pre class="codehilite"><code class="language-php">// Use openssl and provide a private key
$filter = new Zend\Filter\Encrypt([
   'adapter' =&gt; 'openssl',
   'passphrase' =&gt; 'enter here the passphrase for the private key',
   'private' =&gt; '/path/to/mykey/private.pem',
   'public' =&gt; '/public/key/path/public.pem'
]);

$encrypted = $filter-&gt;filter('text_to_be_encoded');
$envelope  = $filter-&gt;getEnvelopeKey();
print $encrypted;

// For decryption look at the Decrypt filter</code></pre>


<h3 id="simplified-usage-with-openssl">Simplified usage with OpenSSL</h3>
<p>As noted in the previous section, you need to provide the envelope key to the
recipient in order for them to decrypt the message. This adds complexity,
particularly if you are encrypting multiple values.</p>
<p>To simplify usage, you can set the <code>package</code> option to <code>TRUE</code> when creating your
<code>Encrypt</code> instance (the default value is <code>FALSE</code>). This will return a value
containing both the encrypted message <em>and</em> the envelope key:</p>
<pre class="codehilite"><code class="language-php">// Use openssl and provide a private key
$filter = new Zend\Filter\Encrypt([
   'adapter' =&gt; 'openssl',
   'private' =&gt; '/path/to/mykey/private.pem',
   'public'  =&gt; '/public/key/path/public.pem',
   'package' =&gt; true,
]);

$encrypted = $filter-&gt;filter('text_to_be_encoded');
print $encrypted;

// For decryption look at the Decrypt filter</code></pre>


<p>Now the returned value contains the encrypted value and the envelope. You don't
need to fetch the envelope key separately.</p>
<p>However, there is one negative aspect to this: the encrypted value can now only
be decrypted by using <code>Zend\Filter\Encrypt</code>.</p>
<h3 id="compressing-content">Compressing Content</h3>
<p>Based on the original value, the encrypted value can be a very large string. To
reduce the value, <code>Zend\Filter\Encrypt</code> allows the usage of compression.</p>
<p>The <code>compression</code> option can either be set to the name of a compression adapter,
or to an array which sets all required options for the compression adapter.</p>
<pre class="codehilite"><code class="language-php">// Use basic compression adapter
$filter1 = new Zend\Filter\Encrypt([
   'adapter'     =&gt; 'openssl',
   'private'     =&gt; '/path/to/mykey/private.pem',
   'public'      =&gt; '/public/key/path/public.pem',
   'package'     =&gt; true,
   'compression' =&gt; 'bz2'
]);

// Compression adatper with options:
$filter2 = new Zend\Filter\Encrypt([
   'adapter'     =&gt; 'openssl',
   'private'     =&gt; '/path/to/mykey/private.pem',
   'public'      =&gt; '/public/key/path/public.pem',
   'package'     =&gt; true,
   'compression' =&gt; ['adapter' =&gt; 'zip', 'target' =&gt; '\usr\tmp\tmp.zip']
]);</code></pre>


<blockquote>
<h4 id="decrypt-using-the-same-settings">Decrypt using the same settings</h4>
<p>When you want to decrypt a value which is additionally compressed, then you
need to set the same compression settings for decryption as for encryption;
otherwise decryption will fail.</p>
</blockquote>
<h3 id="decryption-with-openssl">Decryption with OpenSSL</h3>
<p>Decryption with <code>OpenSSL</code> follows the same patterns as for encryption, with one
difference: you must have all data, including the envelope key, from the person
who encrypted the content.</p>
<p>As an example:</p>
<pre class="codehilite"><code class="language-php">// Use openssl and provide a private key
$filter = new Zend\Filter\Decrypt([
   'adapter' =&gt; 'openssl',
   'private' =&gt; '/path/to/mykey/private.pem'
]);

// Add the envelope key; you can also add this during instantiation.
$filter-&gt;setEnvelopeKey('/key/from/encoder/envelope_key.pem');</code></pre>


<p>If encyption used a passphrase, you'll need to provide that as well:</p>
<pre class="codehilite"><code class="language-php">// Use openssl and provide a private key
$filter = new Zend\Filter\Decrypt([
   'adapter' =&gt; 'openssl',
   'passphrase' =&gt; 'enter here the passphrase for the private key',
   'private' =&gt; '/path/to/mykey/private.pem'
]);

// Add the envelope key; you can also add this during instantiation.
$filter-&gt;setEnvelopeKey('/key/from/encoder/envelope_key.pem');</code></pre>


<p>Finally, you can decode the content.</p>
<p>Our complete example for decrypting the previously encrypted content looks like
this:</p>
<pre class="codehilite"><code class="language-php">// Use openssl and provide a private key
$filter = new Zend\Filter\Decrypt([
   'adapter' =&gt; 'openssl',
   'passphrase' =&gt; 'enter here the passphrase for the private key',
   'private' =&gt; '/path/to/mykey/private.pem'
]);

// Add the envelope key; you can also add this during instantiation.
$filter-&gt;setEnvelopeKey('/key/from/encoder/envelope_key.pem');

$decrypted = $filter-&gt;filter('encoded_text_normally_unreadable');
print $decrypted;</code></pre>


<h2 id="htmlentities">HtmlEntities</h2>
<p>Returns the string <code>$value</code>, converting characters to their corresponding HTML
entity equivalents when possible.</p>
<h3 id="supported-options_10">Supported Options</h3>
<p>The following options are supported for <code>Zend\Filter\HtmlEntities</code>:</p>
<ul>
<li><code>quotestyle</code>: Equivalent to the PHP <code>htmlentities()</code> native function parameter
  <code>quote_style</code>.  This allows you to define what will be done with 'single' and
  "double" quotes. The following constants are accepted: <code>ENT_COMPAT</code>,
  <code>ENT_QUOTES</code>, and <code>ENT_NOQUOTES</code>, with the default being <code>ENT_COMPAT</code>.</li>
<li><code>charset</code>: Equivalent to the PHP <code>htmlentities()</code> native function parameter
  <code>charset</code>. This defines the character set to be used in filtering. Unlike the
  PHP native function, the default is 'UTF-8'. See the <a href="http://php.net/htmlentities">PHP htmlentities
  manual</a> for a list of supported character sets.</li>
</ul>
<p>This option can also be set via the <code>$options</code> parameter as a Traversable
  object or array. The option key will be accepted as either <code>charset</code> or
  <code>encoding</code>.
- <code>doublequote</code>: Equivalent to the PHP <code>htmlentities()</code> native function
  parameter <code>double_encode</code>. If set to <code>false</code>, existing HTML entities will not
  be encoded. The default is to convert everything (<code>true</code>).</p>
<p>This option must be set via the <code>$options</code> parameter or the
  <code>setDoubleEncode()</code> method.</p>
<h3 id="basic-usage_7">Basic Usage</h3>
<pre class="codehilite"><code class="language-php">$filter = new Zend\Filter\HtmlEntities();

print $filter-&gt;filter('&lt;');</code></pre>


<h3 id="quote-style">Quote Style</h3>
<p><code>Zend\Filter\HtmlEntities</code> allows changing the quote style used. This can be useful when you want to
leave double, single, or both types of quotes un-filtered.</p>
<pre class="codehilite"><code class="language-php">$filter = new Zend\Filter\HtmlEntities(['quotestyle' =&gt; ENT_QUOTES]);

$input = &quot;A 'single' and &quot; . '&quot;double&quot;';
print $filter-&gt;filter($input);</code></pre>


<p>The above example returns <code>A &amp;#039;single&amp;#039; and &amp;quot;double&amp;quot;</code>. Notice
that 'single' as well as "double" quotes are filtered.</p>
<pre class="codehilite"><code class="language-php">$filter = new Zend\Filter\HtmlEntities(['quotestyle' =&gt; ENT_COMPAT]);

$input = &quot;A 'single' and &quot; . '&quot;double&quot;';
print $filter-&gt;filter($input);</code></pre>


<p>The above example returns <code>A 'single' and &amp;quot;double&amp;quot;</code>. Notice that
"double" quotes are filtered while 'single' quotes are not altered.</p>
<pre class="codehilite"><code class="language-php">$filter = new Zend\Filter\HtmlEntities(['quotestyle' =&gt; ENT_NOQUOTES]);

$input = &quot;A 'single' and &quot; . '&quot;double&quot;';
print $filter-&gt;filter($input);</code></pre>


<p>The above example returns <code>A 'single' and "double"</code>. Notice that neither
"double" or 'single' quotes are altered.</p>
<h3 id="helper-methods">Helper Methods</h3>
<p>To change or retrieve the <code>quotestyle</code> after instantiation, the two methods
<code>setQuoteStyle()</code> and <code>getQuoteStyle()</code> may be used respectively.
<code>setQuoteStyle()</code> accepts one parameter, <code>$quoteStyle</code>, which accepts one of the
constants <code>ENT_COMPAT</code>, <code>ENT_QUOTES</code>, or <code>ENT_NOQUOTES</code>.</p>
<pre class="codehilite"><code class="language-php">$filter = new Zend\Filter\HtmlEntities();

$filter-&gt;setQuoteStyle(ENT_QUOTES);
print $filter-&gt;getQuoteStyle(ENT_QUOTES);</code></pre>


<p>To change or retrieve the <code>charset</code> after instantiation, the two methods
<code>setCharSet()</code> and <code>getCharSet()</code> may be used respectively. <code>setCharSet()</code>
accepts one parameter, <code>$charSet</code>. See the <a href="http://php.net/htmlentities">PHP htmlentities manual
page</a> for a list of supported character sets.</p>
<pre class="codehilite"><code class="language-php">$filter = new Zend\Filter\HtmlEntities();

$filter-&gt;setQuoteStyle(ENT_QUOTES);
print $filter-&gt;getQuoteStyle(ENT_QUOTES);</code></pre>


<p>To change or retrieve the <code>doublequote</code> option after instantiation, the two methods
<code>setDoubleQuote()</code> and <code>getDoubleQuote()</code> may be used respectively. <code>setDoubleQuote()</code> accepts one
boolean parameter, <code>$doubleQuote</code>.</p>
<pre class="codehilite"><code class="language-php">$filter = new Zend\Filter\HtmlEntities();

$filter-&gt;setQuoteStyle(ENT_QUOTES);
print $filter-&gt;getQuoteStyle(ENT_QUOTES);</code></pre>


<h2 id="toint">ToInt</h2>
<p><code>Zend\Filter\ToInt</code> allows you to transform a scalar value into an integer.</p>
<h3 id="supported-options_11">Supported Options</h3>
<p>There are no additional options for <code>Zend\Filter\ToInt</code>.</p>
<h3 id="basic-usage_8">Basic Usage</h3>
<pre class="codehilite"><code class="language-php">$filter = new Zend\Filter\ToInt();

print $filter-&gt;filter('-4 is less than 0');</code></pre>


<p>This will return '-4'.</p>
<h3 id="migration-from-20-23-to-24">Migration from 2.0-2.3 to 2.4+</h3>
<p>Version 2.4 adds support for PHP 7. In PHP 7, <code>int</code> is a reserved keyword, which required renaming
the <code>Int</code> filter. If you were using the <code>Int</code> filter directly previously, you will now receive an
<code>E_USER_DEPRECATED</code> notice on instantiation. Please update your code to refer to the <code>ToInt</code> class
instead.</p>
<p>Users pulling their <code>Int</code> filter instance from the filter plugin manager receive a <code>ToInt</code> instance
instead starting in 2.4.0.</p>
<h2 id="tonull">ToNull</h2>
<p>This filter will change the given input to be <code>NULL</code> if it meets specific
criteria. This is often necessary when you work with databases and want to have
a <code>NULL</code> value instead of a boolean or any other type.</p>
<h3 id="supported-options_12">Supported Options</h3>
<p>The following options are supported for <code>Zend\Filter\ToNull</code>:</p>
<ul>
<li><code>type</code>: The variable type which should be supported.</li>
</ul>
<h3 id="default-behavior_1">Default Behavior</h3>
<p>Per default this filter works like PHP's <code>empty()</code> method; in other words, if
<code>empty()</code> returns a boolean <code>TRUE</code>, then a <code>NULL</code> value will be returned.</p>
<pre class="codehilite"><code class="language-php">$filter = new Zend\Filter\ToNull();
$value  = '';
$result = $filter-&gt;filter($value);
// returns null instead of the empty string</code></pre>


<p>This means that without providing any configuration, <code>Zend\Filter\ToNull</code> will
accept all input types and return <code>NULL</code> in the same cases as <code>empty()</code>.</p>
<p>Any other value will be returned as is, without any changes.</p>
<h3 id="changing-the-default-behavior_1">Changing the Default Behavior</h3>
<p>Sometimes it's not enough to filter based on <code>empty()</code>. Therefore
<code>Zend\Filter\ToNull</code> allows you to configure which types will be converted, and
which not.</p>
<p>The following types can be handled:</p>
<ul>
<li><code>boolean</code>: Converts a boolean <code>FALSE</code> value to <code>NULL</code>.</li>
<li><code>integer</code>: Converts an integer <code>0</code> value to <code>NULL</code>.</li>
<li><code>empty_array</code>: Converts an empty <code>array</code> to <code>NULL</code>.</li>
<li><code>float</code>: Converts an float <code>0.0</code> value to <code>NULL</code>.</li>
<li><code>string</code>: Converts an empty string <code>''</code> to <code>NULL</code>.</li>
<li><code>zero</code>: Converts a string containing the single character zero (<code>'0'</code>) to <code>NULL</code>.</li>
<li><code>all</code>: Converts all above types to <code>NULL</code>. (This is the default behavior.)</li>
</ul>
<p>There are several ways to select which of the above types are filtered. You can
give one or multiple types and add them, you can give an array, you can use
constants, or you can give a textual string.  See the following examples:</p>
<pre class="codehilite"><code class="language-php">// converts false to null
$filter = new Zend\Filter\ToNull(Zend\Filter\ToNull::BOOLEAN);

// converts false and 0 to null
$filter = new Zend\Filter\ToNull(
    Zend\Filter\ToNull::BOOLEAN + Zend\Filter\ToNull::INTEGER
);

// converts false and 0 to null
$filter = new Zend\Filter\ToNull([
    Zend\Filter\ToNull::BOOLEAN,
    Zend\Filter\ToNull::INTEGER
]);

// converts false and 0 to null
$filter = new Zend\Filter\ToNull([
    'boolean',
    'integer',
]);</code></pre>


<p>You can also give a <code>Traversable</code> or an array to set the wished types. To set
types afterwards use <code>setType()</code>.</p>
<h3 id="migration-from-20-23-to-24_1">Migration from 2.0-2.3 to 2.4+</h3>
<p>Version 2.4 adds support for PHP 7. In PHP 7, <code>null</code> is a reserved keyword, which required renaming
the <code>Null</code> filter. If you were using the <code>Null</code> filter directly previously, you will now receive an
<code>E_USER_DEPRECATED</code> notice on instantiation. Please update your code to refer to the <code>ToNull</code> class
instead.</p>
<p>Users pulling their <code>Null</code> filter instance from the filter plugin manager receive a <code>ToNull</code>
instance instead starting in 2.4.0.</p>
<h2 id="numberformat">NumberFormat</h2>
<p>The <code>NumberFormat</code> filter can be used to return locale-specific number and percentage strings. It
extends the <code>NumberParse</code> filter, which acts as wrapper for the <code>NumberFormatter</code> class within the
Internationalization extension (Intl).</p>
<p>This filter is part of the zend-i18n package; you will need to include that
package in your application to use it.</p>
<h3 id="supported-options_13">Supported Options</h3>
<p>The following options are supported for <code>NumberFormat</code>:</p>
<pre class="codehilite"><code class="language-php">NumberFormat([ string $locale [, int $style [, int $type ]]])</code></pre>


<ul>
<li>
<p><code>$locale</code>: (Optional) Locale in which the number would be formatted (locale
  name, e.g. <code>en_US</code>). If unset, it will use the default locale
  (<code>Locale::getDefault()</code>). Methods for getting/setting the locale are also
  available: <code>getLocale()</code> and <code>setLocale()</code>.</p>
</li>
<li>
<p><code>$style</code>: (Optional) Style of the formatting, one of the
  <a href="http://www.php.net/manual/class.numberformatter.php#intl.numberformatter-constants.unumberformatstyle">format style constants</a>.
  If unset, it will use <code>NumberFormatter::DEFAULT_STYLE</code> as the default style.
  Methods for getting/setting the format style are also available: <code>getStyle()</code>
  and <code>setStyle()</code>.</p>
</li>
<li>
<p><code>$type</code>: (Optional) The <a href="http://www.php.net/manual/class.numberformatter.php#intl.numberformatter-constants.types">formatting type</a>
  to use. If unset, it will use <code>NumberFormatter::TYPE_DOUBLE</code> as the default
  type. Methods for getting/setting the format type are also available:
  <code>getType()</code> and <code>setType()</code>.</p>
</li>
</ul>
<h3 id="basic-usage_9">Basic Usage</h3>
<pre class="codehilite"><code class="language-php">$filter = new \Zend\I18n\Filter\NumberFormat('de_DE');
echo $filter-&gt;filter(1234567.8912346);
// Returns '1.234.567,891'

$filter = new \Zend\I18n\Filter\NumberFormat('en_US', NumberFormatter::PERCENT);
echo $filter-&gt;filter(0.80);
// Returns '80%'

$filter = new \Zend\I18n\Filter\NumberFormat('fr_FR', NumberFormatter::SCIENTIFIC);
echo $filter-&gt;filter(0.00123456789);
// Returns '1,23456789E-3'</code></pre>


<h2 id="numberparse">NumberParse</h2>
<p>The <code>NumberParse</code> filter can be used to parse a number from a string. It acts as
a wrapper for the <code>NumberFormatter</code> class within the Internationalization
extension (Intl).</p>
<p>This filter is part of the zend-i18n package; you will need to include that
package in your application to use it.</p>
<h3 id="supported-options_14">Supported Options</h3>
<p>The following options are supported for <code>NumberParse</code>:</p>
<pre class="codehilite"><code class="language-php">NumberParse([ string $locale [, int $style [, int $type ]]])</code></pre>


<ul>
<li>
<p><code>$locale</code>: (Optional) Locale in which the number would be parsed (locale name,
  e.g. <code>en_US</code>). If unset, it will use the default locale
  (<code>Locale::getDefault()</code>). Methods for getting/setting the locale are also
  available: <code>getLocale()</code> and <code>setLocale()</code>.</p>
</li>
<li>
<p><code>$style</code>: (Optional) Style of the parsing, one of the
  <a href="http://www.php.net/manual/class.numberformatter.php#intl.numberformatter-constants.unumberformatstyle">format style constants</a>.
  If unset, it will use <code>NumberFormatter::DEFAULT_STYLE</code> as the default style.
  Methods for getting/setting the parse style are also available: <code>getStyle()</code>
  and <code>setStyle()</code>.</p>
</li>
<li>
<p><code>$type</code>: (Optional) The <a href="http://www.php.net/manual/class.numberformatter.php#intl.numberformatter-constants.types">parsing type</a>
  to use. If unset, it will use <code>NumberFormatter::TYPE_DOUBLE</code> as the default
  type. Methods for getting/setting the parse type are also available:
  <code>getType()</code> and <code>setType()</code>.</p>
</li>
</ul>
<h3 id="basic-usage_10">Basic Usage</h3>
<pre class="codehilite"><code class="language-php">$filter = new \Zend\I18n\Filter\NumberParse('de_DE');
echo $filter-&gt;filter('1.234.567,891');
// Returns 1234567.8912346

$filter = new \Zend\I18n\Filter\NumberParse('en_US', NumberFormatter::PERCENT);
echo $filter-&gt;filter('80%');
// Returns 0.80

$filter = new \Zend\I18n\Filter\NumberParse('fr_FR', NumberFormatter::SCIENTIFIC);
echo $filter-&gt;filter('1,23456789E-3');
// Returns 0.00123456789</code></pre>


<h2 id="pregreplace">PregReplace</h2>
<p><code>Zend\Filter\PregReplace</code> performs a search using regular expressions and replaces all found
elements.</p>
<h3 id="supported-options_15">Supported Options</h3>
<p>The following options are supported for <code>Zend\Filter\PregReplace</code>:</p>
<ul>
<li><code>pattern</code>: The pattern to search for.</li>
<li><code>replacement</code>: The string which to use as a replacement for the matches; this
  can optionally contain placeholders for matched groups in the search pattern.</li>
</ul>
<h3 id="basic-usage_11">Basic Usage</h3>
<p>To use this filter properly, you must give both options listed above.</p>
<p>The <code>pattern</code> option has to be given to set the pattern to search for. It can be
a string for a single pattern, or an array of strings for multiple patterns.</p>
<p>The <code>replacement</code> option indicates the string to replace matches with, and can
contain placeholders for matched groups from the search <code>pattern</code>. The value may
be a string replacement, or an array of string replacements.</p>
<pre class="codehilite"><code class="language-php">$filter = new Zend\Filter\PregReplace([
    'pattern'     =&gt; '/bob/',
    'replacement' =&gt; 'john',
]);
$input  = 'Hi bob!';

$filter-&gt;filter($input);
// returns 'Hi john!'</code></pre>


<p>You can also use <code>setPattern()</code> to set the pattern(s), and <code>setReplacement()</code> set
the replacement(s).</p>
<pre class="codehilite"><code class="language-php">$filter = new Zend\Filter\PregReplace();
$filter
    -&gt;setPattern(array('bob', 'Hi'))
    -&gt;setReplacement(array('john', 'Bye'));
$input = 'Hi bob!';

$filter-&gt;filter($input);
// returns 'Bye john!'</code></pre>


<p>For more complex usage, read the
<a href="http://www.php.net/manual/en/reference.pcre.pattern.modifiers.php">PCRE Pattern chapter of the PHP manual</a>.</p>
<h2 id="realpath">RealPath</h2>
<p>This filter will resolve given links and pathnames, and returns the canonicalized
absolute pathnames.</p>
<h3 id="supported-options_16">Supported Options</h3>
<p>The following options are supported for <code>Zend\Filter\RealPath</code>:</p>
<ul>
<li><code>exists</code>: This option defaults to <code>TRUE</code>, which validates that the given path
  really exists.</li>
</ul>
<h3 id="basic-usage_12">Basic Usage</h3>
<p>For any given link or pathname, its absolute path will be returned. References
to <code>/./</code>, <code>/../</code> and extra <code>/</code> sequences in the input path will be stripped. The
resulting path will not have any symbolic links, <code>/./</code>, or <code>/../</code> sequences.</p>
<p><code>Zend\Filter\RealPath</code> will return <code>FALSE</code> on failure, e.g. if the file does not exist. On BSD
systems <code>Zend\Filter\RealPath</code> doesn't fail if only the last path component doesn't exist, while
other systems will return <code>FALSE</code>.</p>
<pre class="codehilite"><code class="language-php">$filter = new Zend\Filter\RealPath();
$path = '/www/var/path/../../mypath';
$filtered = $filter-&gt;filter($path);

// returns '/www/mypath'</code></pre>


<h3 id="non-existing-paths">Non-Existing Paths</h3>
<p>Sometimes it is useful to get paths to files that do n0t exist; e.g., when you
want to get the real path for a path you want to create. You can then either
provide a <code>FALSE</code> <code>exists</code> value at initiation, or use <code>setExists()</code> to set it.</p>
<pre class="codehilite"><code class="language-php">$filter = new Zend\Filter\RealPath(false);
$path = '/www/var/path/../../non/existing/path';
$filtered = $filter-&gt;filter($path);

// returns '/www/non/existing/path'
// even when file_exists or realpath would return false</code></pre>


<h2 id="stringtolower">StringToLower</h2>
<p>This filter converts any input to lowercase.</p>
<h3 id="supported-options_17">Supported Options</h3>
<p>The following options are supported for <code>Zend\Filter\StringToLower</code>:</p>
<ul>
<li><code>encoding</code>: This option can be used to set an encoding to use.</li>
</ul>
<h3 id="basic-usage_13">Basic Usage</h3>
<pre class="codehilite"><code class="language-php">$filter = new Zend\Filter\StringToLower();

print $filter-&gt;filter('SAMPLE');
// returns &quot;sample&quot;</code></pre>


<h3 id="handling-alternate-encoding">Handling alternate encoding</h3>
<p>By default, <code>StringToLower</code> will only handle characters from the locale of your
server; characters from other charsets will be ignored. If you have the mbstring
extension, however, you can use the filter with other encodings.  Pass the
desired encoding when initiating the <code>StringToLower</code> filter, or use the
<code>setEncoding()</code> method to change it.</p>
<pre class="codehilite"><code class="language-php">// using UTF-8
$filter = new Zend\Filter\StringToLower('UTF-8');

// or give an array which can be useful when using a configuration
$filter = new Zend\Filter\StringToLower(['encoding' =&gt; 'UTF-8']);

// or do this afterwards
$filter-&gt;setEncoding('ISO-8859-1');</code></pre>


<blockquote>
<h4 id="setting-invalid-encodings">Setting invalid encodings</h4>
<p>Be aware that you will get an exception when:</p>
<ul>
<li>you attempt to set an encoding and the mbstring extension is unavailable; or</li>
<li>you attempt to set an encoding unsupported by the mbstring extension.</li>
</ul>
</blockquote>
<h2 id="stringtoupper">StringToUpper</h2>
<p>This filter converts any input to UPPERCASE.</p>
<h3 id="supported-options_18">Supported Options</h3>
<p>The following options are supported for <code>Zend\Filter\StringToUpper</code>:</p>
<ul>
<li><code>encoding</code>: This option can be used to set the encoding to use.</li>
</ul>
<h3 id="basic-usage_14">Basic Usage</h3>
<pre class="codehilite"><code class="language-php">$filter = new Zend\Filter\StringToUpper();

print $filter-&gt;filter('Sample');
// returns &quot;SAMPLE&quot;</code></pre>


<h3 id="different-encoded-strings">Different Encoded Strings</h3>
<p>Like the <code>StringToLower</code> filter, this filter will only handle characters
supported by your server locale, unless you have the mbstring extension enabled.
Using different character sets works the same as with <code>StringToLower</code>.</p>
<pre class="codehilite"><code class="language-php">$filter = new Zend\Filter\StringToUpper(['encoding' =&gt; 'UTF-8']);

// or do this afterwards
$filter-&gt;setEncoding('ISO-8859-1');</code></pre>


<h2 id="stringtrim">StringTrim</h2>
<p>This filter modifies a given string such that certain characters are removed
from the beginning and end.</p>
<h3 id="supported-options_19">Supported Options</h3>
<p>The following options are supported for <code>Zend\Filter\StringTrim</code>:</p>
<ul>
<li><code>charlist</code>: List of characters to remove from the beginning and end of the
  string. If this is not set or is null, the default behavior will be invoked,
  which is to remove only whitespace from the beginning and end of the string.</li>
</ul>
<h3 id="basic-usage_15">Basic Usage</h3>
<pre class="codehilite"><code class="language-php">$filter = new Zend\Filter\StringTrim();

print $filter-&gt;filter(' This is (my) content: ');</code></pre>


<p>The above example returns <code>This is (my) content:</code>. Notice that the whitespace
characters have been removed.</p>
<h3 id="specifying-alternate-characters">Specifying alternate characters</h3>
<pre class="codehilite"><code class="language-php">$filter = new Zend\Filter\StringTrim(':');
// or new Zend\Filter\StringTrim(array('charlist' =&gt; ':'));

print $filter-&gt;filter(' This is (my) content:');</code></pre>


<p>The above example returns <code>This is (my) content</code>. Notice that the whitespace
characters and colon are removed. You can also provide a <code>Traversable</code> or an
array with a <code>charlist</code> key. To set the desired character list after
instantiation, use the <code>setCharList()</code> method. <code>getCharList()</code> returns the
current character list.</p>
<h2 id="stripnewlines">StripNewlines</h2>
<p>This filter modifies a given string and removes all new line characters within
that string.</p>
<h3 id="supported-options_20">Supported Options</h3>
<p>There are no additional options for <code>Zend\Filter\StripNewlines</code>:</p>
<h3 id="basic-usage_16">Basic Usage</h3>
<pre class="codehilite"><code class="language-php">$filter = new Zend\Filter\StripNewlines();

print $filter-&gt;filter(' This is (my)``\n\r``content: ');</code></pre>


<p>The above example returns <code>This is (my) content:</code>. Notice that all newline
characters have been removed.</p>
<h2 id="striptags">StripTags</h2>
<p>This filter can strip XML and HTML tags from given content.</p>
<blockquote>
<h3 id="zend92filter92striptags-is-potentially-insecure">Zend\Filter\StripTags is potentially insecure</h3>
<p>Be warned that <code>Zend\\Filter\\StripTags</code> should only be used to strip <em>all</em>
available tags.  Using <code>Zend\\Filter\\StripTags</code> to make your site secure by
stripping <em>some</em> unwanted tags will lead to unsecure and dangerous code,
including potential XSS vectors.</p>
<p>For a fully secure solution that allows selected filtering of HTML tags, use
either Tidy or HtmlPurifier.</p>
</blockquote>
<h3 id="supported-options_21">Supported Options</h3>
<p>The following options are supported for <code>Zend\Filter\StripTags</code>:</p>
<ul>
<li><code>allowAttribs</code>: This option sets the attributes which are accepted. All other
  attributes are stripped from the given content.</li>
<li><code>allowTags</code>: This option sets the tags which are accepted. All other tags will
  be stripped from; the given content.</li>
</ul>
<h3 id="basic-usage_17">Basic Usage</h3>
<pre class="codehilite"><code class="language-php">$filter = new Zend\Filter\StripTags();

print $filter-&gt;filter('&lt;B&gt;My content&lt;/B&gt;');</code></pre>


<p>The result will be the stripped content <code>My content</code>.</p>
<p>When the content contains broken or partial tags, any content following the
opening tag will be completely removed:</p>
<pre class="codehilite"><code class="language-php">$filter = new Zend\Filter\StripTags();

print $filter-&gt;filter('This contains &lt;a href=&quot;http://example.com&quot;&gt;no ending tag');</code></pre>


<p>The above will return <code>This contains</code>, with the rest being stripped.</p>
<h3 id="allowing-defined-tags">Allowing Defined Tags</h3>
<p><code>Zend\Filter\StripTags</code> allows stripping all but a whitelist of tags. As an
example, this can be used to strip all markup except for links:</p>
<pre class="codehilite"><code class="language-php">$filter = new Zend\Filter\StripTags(['allowTags' =&gt; 'a']);

$input  = &quot;A text with &lt;br/&gt; a &lt;a href='link.com'&gt;link&lt;/a&gt;&quot;;
print $filter-&gt;filter($input);</code></pre>


<p>The above will return <code>A text with a &lt;a href='link.com'&gt;link&lt;/a&gt;</code>;
it strips all tags but the link. By providing an array, you can specify multiple
tags at once.</p>
<blockquote>
<h4 id="warning">Warning</h4>
<p>Do not use this feature to secure content. This component does not replace the
use of a properly configured html filter.</p>
</blockquote>
<h3 id="allowing-defined-attributes">Allowing Defined Attributes</h3>
<p>You can also strip all but a whitelist of attributes from a tag:</p>
<pre class="codehilite"><code class="language-php">$filter = new Zend\Filter\StripTags([
    'allowTags' =&gt; 'img',
    'allowAttribs' =&gt; 'src',
]);

$input  = &quot;A text with &lt;br/&gt; a &lt;img src='picture.com' width='100'&gt;picture&lt;/img&gt;&quot;;
print $filter-&gt;filter($input);</code></pre>


<p>The above will return <code>A text with a &lt;img src='picture.com'&gt;picture&lt;/img&gt;</code>; it
strips all tags but <code>&lt;img&gt;</code>, and all attributes but <code>src</code> from those tags.By
providing an array you can set multiple attributes at once.</p>
<h3 id="allow-specific-tags-with-specific-attributes">Allow specific tags with specific attributes</h3>
<p>You can also pass the tag whitelist as a set of tag/attribute values. Each key
will be an allowed tag, pointing to a list of whitelisted attributes for that
tag.</p>
<pre class="codehilite"><code class="language-php">$allowedElements = [
    'img' =&gt; [
        'src',
        'width'
    ],
    'a' =&gt; [
        'href'
    ]
];
$filter = new Zend\Filter\StripTags($allowedElements);

$input = &quot;A text with &lt;br/&gt; a &lt;img src='picture.com' width='100'&gt;picture&lt;/img&gt; click &quot;
    . &quot;&lt;a href='http://picture.com/zend' id='hereId'&gt;here&lt;/a&gt;!&quot;;
print $filter-&gt;filter($input);</code></pre>


<p>The above will return <code>A text with a &lt;img src='picture.com'
width='100'&gt;picture&lt;/img&gt; click &lt;a href='&lt;http://picture.com/zend&gt;'&gt;here&lt;/a&gt;!</code>
as the result.</p>
<h2 id="urinormalize">UriNormalize</h2>
<p>This filter sets the scheme on a URI if the scheme is missing.</p>
<h3 id="supported-options_22">Supported Options</h3>
<p>The following options are supported for <code>Zend\Filter\UriNormalize</code>:</p>
<ul>
<li><code>defaultScheme</code>: This option can be used to set the default scheme to use when
  parsing scheme-less URIs.</li>
<li><code>enforcedScheme</code>: Set a URI scheme to enforce on schemeless URIs.</li>
</ul>
<h3 id="basic-usage_18">Basic Usage</h3>
<pre class="codehilite"><code class="language-php">$filter = new Zend\Filter\UriNormalize(array(
    'enforcedScheme' =&gt; 'https'
));

echo $filter-&gt;filter('www.example.com');</code></pre>


<p>The above results int the string <code>https://www.example.com</code>.</p>
<h2 id="whitelist">Whitelist</h2>
<p>This filter will return <code>null</code> if the value being filtered is not present the
filter's allowed list of values. If the value is present, it will return that
value.</p>
<p>For the opposite functionality see the <a href="#blacklist">Blacklist</a> filter.</p>
<h3 id="supported-options_23">Supported Options</h3>
<p>The following options are supported for <code>Zend\Filter\Whitelist</code>:</p>
<ul>
<li><code>strict</code>: Uses strict mode for comparisons; passed to <code>in_array()</code>'s third argument.</li>
<li><code>list</code>: An array of allowed values.</li>
</ul>
<h3 id="basic-usage_19">Basic Usage</h3>
<pre class="codehilite"><code class="language-php">$whitelist = new \Zend\Filter\Whitelist([
    'list' =&gt; ['allowed-1', 'allowed-2']
]);
echo $whitelist-&gt;filter('allowed-2');   // =&gt; 'allowed-2'
echo $whitelist-&gt;filter('not-allowed'); // =&gt; null</code></pre>

<hr />


<nav>
  <ul class="pager hidden-print">
    <li class="previous">
      <a rel="prev" href="../intro/"><i class="fa fa-arrow-left"></i> Previous</a>
    </li>
    <li class="next">
      <a rel="next" href="../word/">Next <i class="fa fa-arrow-right"></i></a>
    </li>
  </ul>
</nav>
</div>
        
    </div>
    <!-- content:end -->

    <div id="footerwrap">
    <div class="container">
        <div class="row site-map">
            <div class="col-lg-3">
              <p>
                <strong>Zend Framework</strong><br />
                <a href="http://framework.zend.com/">framework.zend.com</a><br />
                <a href="https://docs.zendframework.com">docs.zendframework.com</a><br />
                <a href="https://packages.zendframework.com">packages.zendframework.com</a><br />
                <a href="https://apigility.org">apigility.org</a><br />
              </p>
            </div>
        </div>

        <div class="row">
            <div class="col-lg-12 centered">
                <a class="back-to-top" href="#page-top"><i class="fa fa-chevron-circle-up fa-4" aria-hidden="true"></i></a>
            </div>
        </div>

        <div class="spacing"></div>

        <div class="row">
            <div class="col-lg-8">
                <h4>Copyright</h4>
                <div class="hline-w"></div>

                <p>&copy; 2006-2016 by <a href="http://www.zend.com">Zend</a>, a <a href="http://www.roguewave.com/">Rogue Wave Company</a>.</p>
            </div>

            <div class="col-lg-4">
                <h4>Contacts</h4>
                <div class="hline-w"></div>
                <p>
                    <a href="irc://irc.freenode.net/zftalk" class="btn-social btn-outline" alt="IRC" title="IRC"><i class="fa fa-comment"></i></a>
                    <a href="https://github.com/zendframework" class="btn-social btn-outline" alt="Github" title="Github"><i class="fa fa-github"></i></a>
                    <a href="https://twitter.com/zfdevteam" class="btn-social btn-outline" alt="Twitter" title="Twitter"><i class="fa fa-twitter"></i></a>
                </p>
            </div>
        </div>
    </div>
</div>


    <script src="../js/jquery-1.10.2.min.js"></script>
    <script src="../js/bootstrap-3.0.3.min.js"></script>
    <script src="../js/prism-zf.js"></script>

    <script>var base_url = '..';</script>
    <script data-main="../mkdocs/js/search.js" src="../mkdocs/js/require.js"></script>
    <script src="../js/base.js"></script>

    <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <button type="button" class="close" data-dismiss="modal">
                        <span aria-hidden="true">&times;</span>
                        <span class="sr-only">Close</span>
                    </button>
                    <h4 class="modal-title" id="exampleModalLabel">Search</h4>
                </div>
                <div class="modal-body">
                    <p>
                        From here you can search these documents. Enter your search terms below.
                    </p>
                    <form role="form">
                        <div class="form-group">
                            <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query">
                        </div>
                    </form>
                    <div id="mkdocs-search-results"></div>
                </div>
                <div class="modal-footer">
                </div>
            </div>
        </div>
    </div>

    <div class="zf-components">
  <div class="zf-components-grid">
    <div class="zf-logo">
      <a href="http://framework.zend.com" data-toggle="tooltip" data-placement="bottom" title="Go to the ZF homepage"><img src="../img/zf-logo-mark.svg" alt="Zend Framework" width="250" /></a>
    </div>

    <div class="component-list"></div>

    <p class="zf-components-rollup"><a href="#">Hide list</a></p>
  </div>
</div>

    <script>
  // Prepare the component list dropdown for display
  $(function () {
    var components = $(".zf-components"),
        componentList = components.find(".component-list"),
        sidebar = $(".bs-sidebar.affix"),
        sidebarInitialPos = sidebar.css("position"),
        hidden,
        componentToggle = $(".component-toggle"),
        navbar = $(".navbar-fixed-top"),
        rollUpLink = $(".zf-components-rollup a");

    // Initial setup on document load
    components.insertBefore(navbar);
    $(".zf-logo a").tooltip();
    componentToggle.tooltip();
    rollUpLink.attr({ href: "#", alt: "Hide component list" });

    // Cast initial sidebar position value
    if (undefined === sidebarInitialPos) {
      sidebarInitialPos = "fixed";
    }

    // Setup onclick events to toggle list
    componentToggle.click(toggleComponentList);
    rollUpLink.click(toggleComponentList);

    // Toggle the component list display
    function toggleComponentList(event) {
      event.preventDefault();

      if (hidden === undefined) {
        // Not loaded yet; load and display.
        loadComponentList();
        return;
      }

      if (hidden) {
        // Hidden; display.
        showComponentList();
        return;
      }

      // Currently visible; hide
      hideComponentList();
    }

    // Show the component list
    function showComponentList() {
      navbar.css({position: "relative"});
      sidebar.css({position: "relative"});
      components
        .css({"margin-top": "-" + components.outerHeight() + "px"})
        .show()
        .animate({"margin-top": 0}, {
          complete: function () {
            componentToggle
              .data("placement", "top")
              .attr("data-original-title", "Hide component list");
            hidden = false;
          },
          queue: false
        });
    }

    // Hide the component list
    function hideComponentList() {
      components.animate({"margin-top": "-" + components.outerHeight() + "px"}, {
        complete: function () {
          navbar.css({position: "fixed"});
          sidebar.css({position: sidebarInitialPos});
          componentToggle
            .data("placement", "bottom")
            .attr("data-original-title", "Show component list");
          components.hide();
          hidden = true;
        },
        queue: false
      });
      sidebar.animate({ top: sidebarInitialTop + "px" }, { queue: false});
    }

    // Inject a component into the componet list DOM.
    function injectComponent(index, component) {
      componentList.append('<div class="component"><h4><a href="' + component.url + '">' + component.name + '</a></h4><p>' + component.description + '</p></div>');
    }

    // Parse the component list, build the DOM, and display it.
    function parseComponentList(components) {
      $.each(components, injectComponent);
      showComponentList();
    }

    // Fetch the component list and display it.
    function loadComponentList () {
      $.ajax({
        url: "//docs.zendframework.com/zf-mkdoc-theme/scripts/zf-component-list.json",
        dataType: "text json",
        success: parseComponentList,
        error: function (e) {
          console.log("Error occurred with XHR call", e);
        }
      });
    }
  });
</script>
    </body>

</html>
